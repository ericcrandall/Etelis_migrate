[
  {
    "objectID": "Etelis_migrate.html",
    "href": "Etelis_migrate.html",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "",
    "text": "Here I’m just loading a bunch of R packages that we’ll need.\n\n\nCode\nlibrary(tidyverse)\nlibrary(ape)\nlibrary(phangorn)\nlibrary(pegas)\n#library(strataG)\nlibrary(coda)\nlibrary(ggmcmc)\nlibrary(perm)\nlibrary(snpR)\nlibrary(adegenet)\nlibrary(pcadapt)\nlibrary(knitr)\nlibrary(graph4lg)\nlibrary(spatstat.core)\nlibrary(Rmpfr)\nlibrary(emoji)\nlibrary(RColorBrewer)\nlibrary(colorspace)\nlibrary(latex2exp)\nlibrary(ggridges)\n\n\n\n\n\nAnd here are some homebrewed functions that will be helpful.\n\n\nCode\n# Function library\nharvest.model.likelihoods <- function(workingDir = workingDir,\n                                      outfileName = \"outfile.txt\",\n                                      multilocus = T){\n    # this function harvests model marginal likelihoods for models calculated by\n    # the program migrate-n (Beerli & Felsenstein 2001).\n    # It takes as input a directory full of directories, \n    # each of which contains output from a migrate model, and is named\n    # after that model. \n  \n    #initialize a data frame to take the values\n    modelMarglikes <- data.frame(model=character(),\n                             thermodynamic=numeric(),\n                             bezier.corrected=numeric(), \n                             harmonic=numeric()) \n    # loop through directories in the working directory, each of which is name\n    # after a different model\n  for(i in list.dirs(workingDir, full.names = F)[-1]){ #i<-\"stepping.stone\"\n      modelDir<-file.path(workingDir,i)\n      print(modelDir)\n    #scan in the outfile, separating at each newline\n      outfile<-scan(file=file.path(modelDir,outfileName),what=\"character\",sep=\"\\n\") \n    #find the line with the likelihoods on it and split on runs of spaces\n      marglikeline <- grep(\"Scaling factor\",outfile,value=F)-1\n      marglikeline <- strsplit(outfile[marglikeline],\n                               \"\\\\s+\", perl = T)[[1]][3:5]\n    #  if(length(marglikeline)==0){next}\n      marglikes <- c(i,marglikeline)\n     \n      modelMarglikes <- rbind(modelMarglikes,marglikes, deparse.level = 2)\n  }\n  names(modelMarglikes) <- c(\"model\",\"thermodynamic\",\"bezier.corrected\",\"harmonic\")\n  modelMarglikes[2:4] <- sapply(modelMarglikes[2:4], as.numeric)\n  return(modelMarglikes)\n}\n\nbfcalcs<-function(df,ml=\"bezier.corrected\"){\n  # This calculates log bayes factors on data frames output by\n  # harvest.model.likelihoods(), following Johnson and Omland (2004)\n  # You may choose the likelihood flavor with\n  # ml = \"bezier.corrected\", \"thermodynamic\" or \"harmonic\"\n  #df$thermodynamic <- as.numeric(df$thermodynamic)\n  #df$bezier.corrected <- as.numeric(df$bezier.corrected)\n  #df$harmonic <- as.numeric(df$harmonic)\n  mlcol <- df[[ml]] \n    bmvalue <- mlcol[which.max(mlcol)]\n    lbf <- 2*(mlcol-bmvalue)\n    choice <- rank(-mlcol)\n    modelprob <- exp(lbf/2)/sum(exp(lbf/2))\n    dfall <- cbind(df,lbf,choice,modelprob)\n    return(dfall)\n}   \n\nmigrants.per.gen<-function(x){\n  #a function for creating Nm vectors out of m and Theta vectors.\n  #x<-x[[1]]\n  m<-names(x)[which(grepl(\"M_\",names(x)))] #names of m columns\n  #theta<-names(x)[which(grepl(\"Theta_\",names(x)))] #names of theta columns\n  for(n in m){\n    t<-paste(\"Theta\",strsplit(n,split=\"_\")[[1]][3],sep=\"_\")\n    x[,paste(\"Nm\",strsplit(n,split=\"_\")[[1]][2],strsplit(n,split=\"_\")[[1]][3],sep=\"_\")]<- x[,which(names(x)==n)]*x[,which(names(x)==t)] \n    #this hairy little statement makes a new column named \"Nm_X_Y\" and then fills it by multiplying the M_X_Y column by the Theta_Y column  \n  }\n  return(x)\n}\n\n######Functions for summing over loci in a bayesallfile###############################\n\nremove_prior <- function(densityd,prior,threshold = 1e-10){\n  # this function changes values less than a threshold \n  # to zero removes a prior from the \n  # y values of a density distributions (density).\n  # first it zeros values less than a threshold, then \n  # removes the prior, then renormalizes so the density\n  # sums to 1\n  prior[which(prior < 1e-30)] <- 1e-30\n  densityd[which(densityd < threshold)] <- 0\n  new <- (densityd/prior)/sum(densityd/prior)\n\n  return(new)\n}\n\nsum_over_loci <- function(df,parameter){\n      #this function takes a data frame of probability densities for many loci\n      # that have had the prior removed,\n      # together with with a logged prior named \"logPrior\",\n      #  as well as the name of a parameter (e.g. \"Theta_1\")\n      # and sums the densities over loci.\n       # Rmpfr package allows quadruple precision for calcs on very small numbers.\n    require(Rmpfr)\n  \n    #add a teeny-tiny amount to all values to avoid zeros\n    df2 <- df %>% mutate(across(starts_with(parameter), \n                        .fns= function(x) x + 1e-11))  %>% \n      #log all values\n            mutate(across(starts_with(c(parameter)),\n                  .fns=log)) %>% \n      # convert the df to rowwise so that rows can be summed\n      # and then sum across the row, including the prior\n          rowwise() %>% \n          mutate(sum_param_prior = \n          sum(c_across(starts_with(c(parameter,\"logPrior\"))))) %>% \n    #convert back to a regular df\n          ungroup()\n    \n    #need to convert to quadruple precision because \n    #these will exponentiate to very small numbers.\n    sum_param_prior_exp <- exp(mpfr(df2$sum_param_prior, precBits = 128))\n    # standardize by dividing by the sum of the column\n    sum_param_prior_standardized <-\n             sum_param_prior_exp/sum(sum_param_prior_exp)\n    \n\n    #drop the intermediate columns (no longer needed), change the standardized\n    # output back to double precision so that it can be incorporated into the df\n    # rename the summed column after the parameter\n      df3 <- df2 %>% select(-c(sum_param_prior)) %>%\n          mutate(summed_over_loci =\n          as.numeric(sum_param_prior_standardized)) %>% \n          rename_with(.fn = ~ paste(parameter), \n                      .cols = summed_over_loci)\n    return(df3)\n}\n\n\n\nsummarize_posterior <- function(posterior, \n                  parameter_type = c(\"Theta\",\"M\",\"Nm\",\"D\"),\n                  prior_params = c(min,mean,max),\n                  n=16384){\n  # this function takes a Migrate-n posterior \"bayesallfile\" as a dataframe\n  # as well as one of the parameter types, and the prior on that parameter\n  # as a vector c(min,mean,max). Currently only exponential priors supported\n  # it will create densities for each parameter of the given type,\n  # remove the prior from each, sum across loci, and re-add the prior (once)\n  parameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n  # create a tibble with the x values for all density plots \n  #  for a particular parameter type\n  getx <- posterior %>% filter(Locus == 1) %>% \n        select(parameters[1])\n\n  # create a tibble with x values for a density plot\n  #  of the chosen number of points\n  dens <- tibble(.rows = n, x = density(getx[[1]],  n=n, \n                           from = prior_params[1], \n                           to = prior_params[3],\n                           bw = \"nrd0\")$x)\n  print(\"calculating densities\")\n  # calculate densities for each parameter of a given type at each locus\n  dens <- posterior %>% \n          select(starts_with(c(\"Steps\",\"Locus\",\"rep\",\n                  paste0(parameter_type,\"_\")))) %>% \n          pivot_wider(names_from = \"Locus\", values_from = \n                  starts_with(paste0(parameter_type,\"_\")),\n                          names_sep = \"-\") %>% \n          select(starts_with(paste0(parameter_type,\"_\"))) %>% \n          map_dfc(function(x) density(x, n = n, from = \n                                    prior_params[1], \n                                    to = prior_params[3], \n                                    bw = \"nrd0\")$y) %>%\n          bind_cols(dens)\n  \n  # create, standardize, log and remove prior\n  dens$prior <- dexp(dens$x, rate = 1/prior_params[2], \n                     log = F)\n  \n  dens$prior <- dens$prior/sum(dens$prior)\n  \n  dens$logPrior <- log(dens$prior)\n  \n  print(\"removing prior\")\n  dens2 <- dens %>% \n        #remove the prior, standardize\n        mutate(across(starts_with(parameter_type), \n                  ~ remove_prior(densityd = .x,\n                                  prior = dens$prior,\n                                  threshold = 1e-10) ))\n\n  dens3 <- dens2\n    \n  for(p in parameters){\n    print(p)  \n    dens3 <- sum_over_loci(df = dens3, parameter = p)\n  }\n  # trying to do the above loop with purrr:map_dfc\n  #dens4 <- parameters %>% \n  #        map_dfc(.f = ~ sum_over_loci(df = dens2, parameter = .x))\n  return(dens3)\n}\n\nposterior_stats <- function(df,parameter){\n  require(spatstat.core)\n  p <- df %>% select(x,parameter) %>% as.list(bw = 6.33e-05)\n  names(p) <- c(\"x\", \"y\")\n  p$bw <- 6.33e-5\n  attr(p, \"class\") <- \"density\"\n  qu <- quantile.density(p, c(0.025, 0.25, 0.5, 0.75, 0.975))\n  wmo <- p$x[which(p$y==max(p$y))]\n  wme <- weighted.mean(p$x, p$y)\n  wsd <- sqrt(weighted.var(p$x, p$y))\n  stats <- c(qu,mode = wmo, mean = wme, sd = wsd)\n  return(stats)\n}"
  },
  {
    "objectID": "Etelis_migrate.html#clean-the-data-with-process_radtags",
    "href": "Etelis_migrate.html#clean-the-data-with-process_radtags",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Clean the data with process_radtags",
    "text": "Clean the data with process_radtags\nSame commands for carbunculus and coruscans. Paired end. Look for ecoR1 cutsites on read 1 and mspI cutsites on read 2. Remove low quality reads (based on a sliding window average). Remove reads smaller than 145 bp, and trim others to that length.\n\nprocess_radtags -p ./raw/ -o ./cleaned/ --rescue --clean --quality --paired --threads 12 --renz-1 ecoRI --renz-2 mspI  \\\n                  --truncate 145 --len-limit 145 \\\n                  --adapter-1 GATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATCTCGTATGCCGTCTTCTGCTTG \\\n                  --adapter-2 AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCGTATCATT \\\n                  --adapter-mm 2\n\n\nE. carbunculus output\nBEGIN total_raw_read_counts  \nTotal Sequences 255732606  \nReads containing adapter sequence       1957206 0.8%  \nBarcode Not Found       0       0.0%  \nLow Quality     6558845 2.6%  \nRAD Cutsite Not Found   1678118 0.7%  \nRetained Reads  245538437       96.0%  \nEND total_raw_read_counts  \n\n\nE. coruscans output\nBEGIN total_raw_read_counts  \nTotal Sequences 272955592  \nReads containing adapter sequence       1919907 0.7%  \nBarcode Not Found       0       0.0%  \nLow Quality     8734891 3.2%  \nRAD Cutsite Not Found   1884115 0.7%  \nRetained Reads  260416679       95.4%  \nEND total_raw_read_counts"
  },
  {
    "objectID": "Etelis_migrate.html#running-the-denovo_map.pl-pipeline",
    "href": "Etelis_migrate.html#running-the-denovo_map.pl-pipeline",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Running the denovo_map.pl pipeline",
    "text": "Running the denovo_map.pl pipeline\nHmm… gotta rename the cleaned files too. All code is being run on both species.\n\nMore renaming\n\ncd cleaned\nfor f in *001.1.fq.gz\ndo\nmv $f ${f/_R[12]_001.1.fq.gz/.1.fq.gz}\ndone\n\nfor f in *001.2.fq.gz\ndo\nmv $f ${f/_R[12]_001.2.fq.gz/.2.fq.gz}\ndone\n\n#rename the \"remainder reads\" that have had their pair removed for low quality\nfor f in *001.rem.1.fq.gz; do mv $f ${f/_R[12]_001.rem.1.fq.gz/.rem.1.fq.gz}; done\nfor f in *001.rem.2.fq.gz; do mv $f ${f/_R[12]_001.rem.2.fq.gz/.rem.2.fq.gz}; done"
  },
  {
    "objectID": "Etelis_migrate.html#removing-extra-flags",
    "href": "Etelis_migrate.html#removing-extra-flags",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Removing extra flags",
    "text": "Removing extra flags\nOy - so denovo_map.pl crashed with this message:\n\nError: Failed to find any matching paired-end reads in ‘./cleaned/Etelis_S36.2.fq.gz’.\nAborted.\n\nJulian Catchen gives the solution here. Because these data were already run through process_radtags once to demultiplex them, it attached a \\1 to the labels of all primary reads and a \\2 to the labels of all paired reads. When I re-ran them in process_radtags, it attached an extra flag to each, which then confused tsv2bam. Julian provides the below code to remove the extra flags.\n\nls  -1 *.1.fq.gz | sed -E 's/\\.1\\.fq\\.gz//' | while read line; do zcat ${line}.1.fq.gz | sed -E 's/\\/1$//' > ../cleaned/${line}.1.fq; done\n\nls  -1 *.2.fq.gz | sed -E 's/\\.2\\.fq\\.gz//' | while read line; do zcat ${line}.2.fq.gz | sed -E 's/\\/2$//' > ../cleaned/${line}.2.fq; done\n\ncd ../cleaned\n\nparallel gzip ::: *"
  },
  {
    "objectID": "Etelis_migrate.html#run-denovo_map.pl",
    "href": "Etelis_migrate.html#run-denovo_map.pl",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Run denovo_map.pl",
    "text": "Run denovo_map.pl\nI’m going to use the denovo_map.pl pipeline. This command will take data from ./cleaned and the popmap provided by Anne and -m 5 reads per stack, -M 4 distance between stacks, -n 4 distance between catalog loci. Running on 8 -T threads and only keeping loci that appear in 80% of individuals in all 4 populations\n\ndenovo_map.pl --samples ./cleaned/ --popmap popmapECA.tsv --out-path ./pipeline --paired \\\n-m 5 -M 4 -n 4  -T 12 -r 80 -p 4 -X \"populations: --fasta-samples\" -X \"populations: --filter-haplotype-wise\""
  },
  {
    "objectID": "Etelis_migrate.html#populations",
    "href": "Etelis_migrate.html#populations",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Populations",
    "text": "Populations\nNow I need to re-run populations to get more statistics. Original populations output is in output1, this will be in output2.\n\nr80\nSettings for keeping loci that occur in 80 percent of indivs per population (so 4/5 of the Johnston invivs for coruscans). I’m being intentionally stringent by setting the p-value cutoff for hwe at 0.05.\n\npopulations -P ./ -O ./output2_r80 -M ../popmapECO.tsv -t 12 -p 4 -r 80 -H --hwe --fstats --p-value-cutoff 0.05 --fasta-loci --fasta-samples --vcf --genepop --structure --treemix --fasta-samples-raw \n\n\nE. carbunculus\nRemoved 98351 loci that did not pass sample/population constraints from 115429 loci.\nKept 17078 loci, composed of 5539395 sites; 17697 of those sites were filtered, 49261 variant sites remained.\nNumber of loci with PE contig: 17078.00 (100.0%);\n  Mean length of loci: 314.36bp (stderr 0.38);\nNumber of loci with SE/PE overlap: 2546.00 (14.9%);\n  Mean length of overlapping loci: 285.08bp (stderr 0.47); mean overlap: 27.61bp (stderr 0.13);\nMean genotyped sites per locus: 315.85bp (stderr 0.37).\n\nPopulation summary statistics (more detail in populations.sumstats_summary.tsv):\n  Japan: 13.333 samples per locus; pi: 0.16058; all/variant/polymorphic sites: 5394107/49261/33997; private alleles: 6596\n  MHI: 13.55 samples per locus; pi: 0.15487; all/variant/polymorphic sites: 5394107/49261/31541; private alleles: 3166\n  NWHI: 25.142 samples per locus; pi: 0.15329; all/variant/polymorphic sites: 5394107/49261/38082; private alleles: 7321\n\nNumber of variable sites found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Japan: 1145\n  MHI: 1103\n  NWHI: 1527\nNumber of loci found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Japan: 3917\n  MHI: 4185\n  NWHI: 3407\n(more detail in populations.sumstats.tsv and populations.hapstats.tsv)\n\nPopulation pair divergence statistics (more in populations.fst_summary.tsv and populations.phistats_summary.tsv):\n  Japan-MHI: mean Fst: 0.030208; mean Phi_st: 0.023147; mean Fst': 0.025616; mean Dxy: 0.0019853\n  Japan-NWHI: mean Fst: 0.02638; mean Phi_st: 0.028095; mean Fst': 0.029652; mean Dxy: 0.0019372\n  MHI-NWHI: mean Fst: 0.014407; mean Phi_st: 0.0018347; mean Fst': 0.0016037; mean Dxy: 0.0018308\n\n\nE. coruscans\nRemoved 130579 loci that did not pass sample/population constraints from 141967 loci.\nKept 11388 loci, composed of 3690405 sites; 32281 of those sites were filtered, 59470 variant sites remained.\nNumber of loci with PE contig: 11388.00 (100.0%);\n  Mean length of loci: 314.06bp (stderr 0.42);\nNumber of loci with SE/PE overlap: 1079.00 (9.5%);\n  Mean length of overlapping loci: 291.05bp (stderr 0.59); mean overlap: 24.47bp (stderr 0.12);\nMean genotyped sites per locus: 315.02bp (stderr 0.42).\n\nPopulation summary statistics (more detail in populations.sumstats_summary.tsv):\n  Johnston_Atoll: 4.1993 samples per locus; pi: 0.074411; all/variant/polymorphic sites: 3587423/59470/15449; private alleles: 5208\n  MHI: 13.68 samples per locus; pi: 0.060304; all/variant/polymorphic sites: 3587423/59470/25569; private alleles: 7241\n  NWHI: 26.37 samples per locus; pi: 0.060932; all/variant/polymorphic sites: 3587423/59470/38902; private alleles: 15366\n  Japan: 13.217 samples per locus; pi: 0.054013; all/variant/polymorphic sites: 3587423/59470/22717; private alleles: 6028\n\nNumber of variable sites found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 7\n  MHI: 1134\n  NWHI: 1648\n  Japan: 700\nNumber of loci found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 3998\n  MHI: 2984\n  NWHI: 2673\n  Japan: 3395\n(more detail in populations.sumstats.tsv and populations.hapstats.tsv)\n\nPopulation pair divergence statistics (more in populations.fst_summary.tsv and populations.phistats_summary.tsv):\n  Johnston_Atoll-MHI: mean Fst: 0.038243; mean Phi_st: 0.012337; mean Fst': 0.0011598; mean Dxy: 0.0014711\n  Johnston_Atoll-NWHI: mean Fst: 0.022267; mean Phi_st: 0.0056917; mean Fst': -0.0033667; mean Dxy: 0.0013478\n  Johnston_Atoll-Japan: mean Fst: 0.041778; mean Phi_st: 0.018924; mean Fst': 0.0048455; mean Dxy: 0.0014546\n  MHI-NWHI: mean Fst: 0.013568; mean Phi_st: 0.0027592; mean Fst': 0.0011102; mean Dxy: 0.0012735\n  MHI-Japan: mean Fst: 0.021407; mean Phi_st: 0.0058972; mean Fst': 0.0028619; mean Dxy: 0.0013316\n  NWHI-Japan: mean Fst: 0.013484; mean Phi_st: 0.002933; mean Fst': 0.0018245; mean Dxy: 0.0012352\n\n\n\nr100\nSettings for keeping loci that occur in 100 percent of indivs per population ::: {.cell}\npopulations -P ./ -O ./output3_r100 -M ../popmapECO.tsv -t 12 -p 4 -r 100 -H --hwe --fstats --p-value-cutoff 0.05 --fasta-loci --fasta-samples --vcf --genepop --structure --treemix --fasta-samples-raw \n\n# and again with single SNPs from each locus so we can test for linkage and selection\npopulations -P ./ -O ./output4_r100.SNP -M ../popmapECA.tsv -t 12 -p 3 -r 100 --hwe --fstats --p-value-cutoff 0.05  --vcf --genepop  --write-random-snp\n\n#Rerun coruscans after dropping A150\npopulations -P ./ -O ./output5_r100.dropA150 -M ../popmapECO2.tsv -t 12 -p 4 -r 100 -H --hwe --fstats --p-value-cutoff 0.05 --fasta-loci --fasta-samples --vcf --genepop --structure --treemix --fasta-samples-raw \n\npopulations -P ./ -O ./output6_r100.dropA150.SNP -M ../popmapECO2.tsv -t 12 -p 4 -r 100 --hwe --fstats --p-value-cutoff 0.05  --vcf --genepop  --write-random-snp\n:::\n\nE. carbunculus\nRemoved 111882 loci that did not pass sample/population constraints from 115429 loci.\nKept 3547 loci, composed of 1134453 sites; 6916 of those sites were filtered, 6537 variant sites remained.\nNumber of loci with PE contig: 3547.00 (100.0%);\n  Mean length of loci: 309.83bp (stderr 0.69);\nNumber of loci with SE/PE overlap: 288.00 (8.1%);\n  Mean length of overlapping loci: 285.06bp (stderr 1.00); mean overlap: 24.45bp (stderr 0.24);\nMean genotyped sites per locus: 310.68bp (stderr 0.68).\n\nPopulation summary statistics (more detail in populations.sumstats_summary.tsv):\n  Japan: 14 samples per locus; pi: 0.10528; all/variant/polymorphic sites: 1101972/6537/3955; private alleles: 1170\n  MHI: 14 samples per locus; pi: 0.09766; all/variant/polymorphic sites: 1101972/6537/3434; private alleles: 511\n  NWHI: 27 samples per locus; pi: 0.097747; all/variant/polymorphic sites: 1101972/6537/4642; private alleles: 1340\n\nNumber of variable sites found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Japan: 101\n  MHI: 90\n  NWHI: 110\nNumber of loci found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Japan: 1197\n  MHI: 1358\n  NWHI: 1331\n(more detail in populations.sumstats.tsv and populations.hapstats.tsv)\n\nPopulation pair divergence statistics (more in populations.fst_summary.tsv and populations.phistats_summary.tsv):\n  Japan-MHI: mean Fst: 0.025802; mean Phi_st: 0.015567; mean Fst': 0.0094451; mean Dxy: 0.00087231\n  Japan-NWHI: mean Fst: 0.020607; mean Phi_st: 0.018272; mean Fst': 0.010517; mean Dxy: 0.00082861\n  MHI-NWHI: mean Fst: 0.012892; mean Phi_st: 0.00097809; mean Fst': 0.00022075; mean Dxy: 0.00081207\n\n\nE. coruscans\nRemoved 140925 loci that did not pass sample/population constraints from 141967 loci.\nKept 1042 loci, composed of 334846 sites; 3569 of those sites were filtered, 3654 variant sites remained.\nNumber of loci with PE contig: 1042.00 (100.0%);\n  Mean length of loci: 311.35bp (stderr 1.36);\nNumber of loci with SE/PE overlap: 117.00 (11.2%);\n  Mean length of overlapping loci: 285.68bp (stderr 1.71); mean overlap: 24.41bp (stderr 0.38);\nMean genotyped sites per locus: 312.62bp (stderr 1.33).\n\nPopulation summary statistics (more detail in populations.sumstats_summary.tsv):\n  Johnston_Atoll: 5 samples per locus; pi: 0.060494; all/variant/polymorphic sites: 325749/3654/975; private alleles: 520\n  MHI: 14 samples per locus; pi: 0.036669; all/variant/polymorphic sites: 325749/3654/1226; private alleles: 470\n  NWHI: 27 samples per locus; pi: 0.037317; all/variant/polymorphic sites: 325749/3654/2064; private alleles: 1019\n  Japan: 14 samples per locus; pi: 0.033766; all/variant/polymorphic sites: 325749/3654/1143; private alleles: 463\n\nNumber of variable sites found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 0\n  MHI: 32\n  NWHI: 45\n  Japan: 19\nNumber of loci found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 524\n  MHI: 422\n  NWHI: 405\n  Japan: 396\n(more detail in populations.sumstats.tsv and populations.hapstats.tsv)\n\nPopulation pair divergence statistics (more in populations.fst_summary.tsv and populations.phistats_summary.tsv):\n  Johnston_Atoll-MHI: mean Fst: 0.039663; mean Phi_st: 0.02039; mean Fst': 0.0012821; mean Dxy: 0.00073676\n  Johnston_Atoll-NWHI: mean Fst: 0.026268; mean Phi_st: 0.015567; mean Fst': 0.00037957; mean Dxy: 0.0006556\n  Johnston_Atoll-Japan: mean Fst: 0.041015; mean Phi_st: 0.020409; mean Fst': 0.0021605; mean Dxy: 0.0007176\n  MHI-NWHI: mean Fst: 0.012433; mean Phi_st: 0.00025697; mean Fst': 4.0397e-05; mean Dxy: 0.00049144\n  MHI-Japan: mean Fst: 0.019806; mean Phi_st: 0.0039369; mean Fst': 0.00060169; mean Dxy: 0.00050736\n  NWHI-Japan: mean Fst: 0.012751; mean Phi_st: 0.0020762; mean Fst': 0.00052502; mean Dxy: 0.00047009\n\nAfter dropping A150\nA150 is a bad apple. I dropped it from the popmap and re-ran\nRemoved 140852 loci that did not pass sample/population constraints from 141967 loci.\nKept 1115 loci, composed of 355817 sites; 3712 of those sites were filtered, 3592 variant sites remained.\nNumber of loci with PE contig: 1115.00 (100.0%);\n  Mean length of loci: 309.12bp (stderr 1.35);\nNumber of loci with SE/PE overlap: 162.00 (14.5%);\n  Mean length of overlapping loci: 279.02bp (stderr 1.56); mean overlap: 25.85bp (stderr 0.33);\nMean genotyped sites per locus: 310.72bp (stderr 1.32).\n\nPopulation summary statistics (more detail in populations.sumstats_summary.tsv):\n  Johnston_Atoll: 4 samples per locus; pi: 0.043022; all/variant/polymorphic sites: 346452/3592/554; private alleles: 160\n  MHI: 14 samples per locus; pi: 0.041745; all/variant/polymorphic sites: 346452/3592/1347; private alleles: 506\n  NWHI: 27 samples per locus; pi: 0.042774; all/variant/polymorphic sites: 346452/3592/2295; private alleles: 1180\n  Japan: 14 samples per locus; pi: 0.037868; all/variant/polymorphic sites: 346452/3592/1241; private alleles: 502\n\nNumber of variable sites found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 0\n  MHI: 37\n  NWHI: 49\n  Japan: 21\nNumber of loci found to be significantly out of Hardy-Weinberg equilibrium (<0.05):\n  Johnston_Atoll: 709\n  MHI: 446\n  NWHI: 414\n  Japan: 422\n(more detail in populations.sumstats.tsv and populations.hapstats.tsv)\n\nPopulation pair divergence statistics (more in populations.fst_summary.tsv and populations.phistats_summary.tsv):\n  Johnston_Atoll-MHI: mean Fst: 0.030722; mean Phi_st: -0.0013119; mean Fst': -0.0016144; mean Dxy: 0.00063351\n  Johnston_Atoll-NWHI: mean Fst: 0.015585; mean Phi_st: -0.014286; mean Fst': -0.0023453; mean Dxy: 0.00053846\n  Johnston_Atoll-Japan: mean Fst: 0.032038; mean Phi_st: -0.002018; mean Fst': -0.00092502; mean Dxy: 0.00060796\n  MHI-NWHI: mean Fst: 0.012297; mean Phi_st: -0.00015381; mean Fst': -7.5242e-05; mean Dxy: 0.00051624\n  MHI-Japan: mean Fst: 0.019801; mean Phi_st: 0.0038246; mean Fst': 0.00053071; mean Dxy: 0.00052919\n  NWHI-Japan: mean Fst: 0.012569; mean Phi_st: 0.0014773; mean Fst': 0.00052976; mean Dxy: 0.00049003"
  },
  {
    "objectID": "Etelis_migrate.html#download-the-populations-output",
    "href": "Etelis_migrate.html#download-the-populations-output",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Download the populations output",
    "text": "Download the populations output\n\nscp -r argo:./Etelis/coruscans/pipeline/output3_r100 ./populations_r100\nscp -r argo:./Etelis/carbunculus/pipeline/output3_r100 ./populations_r100 \n#copy down files from the coruscans run with bad apples removed.\nscp -r argo:./Etelis/coruscans/pipeline/output5_r100.dropA150 ./populations_r100.dropA150\nscp -r argo:./Etelis/coruscans/pipeline/output6_r100.dropA150.SNP/populations.snps.genepop  ./populations_r100.dropA150/populations.randsnp.genepop"
  },
  {
    "objectID": "Etelis_migrate.html#e.-coruscans-2",
    "href": "Etelis_migrate.html#e.-coruscans-2",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "E. coruscans",
    "text": "E. coruscans\n\nAdegenet\nI am testing differences among 4 a priori defined populations. Thus, following recommendations in (Thia 2022), I will only use k-1 or 3 PCA axes.\n\necor_haps <- read.genepop(\"coruscans/populations_r100/populations.haps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Stacks v2.61; GenePop v4.1.3; September 30, 2022 \n\n...done.\n\nlevels(ecor_haps$pop) <- c(\"JA\",\"MHI\",\"NWHI\",\"JP\")\n\necor_dapc_haps <- dapc(ecor_haps,pop =  ecor_haps$pop, scale = T, pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecor_dapc_haps)\n\n\n\necor_hwe <- hw.test(ecor_haps, B = 1000)\n\n# playing with cross-validation\n#xvalDapc(ecor_haps, grp = ecor_haps$pop, result = \"overall\", n.pca.max = 10, training.set = 0.75)\n\nLet’s take a look with the randomly selected SNPs\n\necor_snps.genind <- read.genepop(\"coruscans/populations_r100/populations.randsnp.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  # Stacks v2.61; GenePop v4.1.3; September 30, 2022 \n\n...done.\n\nlevels(ecor_snps.genind$pop) <- c(\"JA\",\"MHI\",\"NWHI\",\"JP\")\n\necor_dapc_snps <- dapc(ecor_snps.genind,pop =  ecor_snps.genind$pop, scale = T,\n                       pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecor_dapc_snps)\n\n\n\n\n\n\nSNPr\nI will use Will Hemstrom’s new package SNPr to further evaluate and filter the SNPs that I randomly selected from each locus.\n\npopmap_cor <- read_tsv(\"coruscans/popmapECO.tsv\",col_names = c(\"sampID\",\"pop\"))\n\nRows: 60 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): sampID, pop\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\necor_snps <- read_vcf(file = \"coruscans/populations_r100/populations.randsnp.vcf\",\n                      sample.meta = popmap_cor)\n\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 14\n  header_line: 15\n  variant count: 929\n  column count: 69\n\nMeta line 14 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 929\n  Character matrix gt cols: 69\n  skip: 0\n  nrows: 929\n  row_num: 0\n\nProcessed variant: 929\nAll variants processed\n\n\n\nFiltering\nI’ve already implemented stringent filters in Stacks to only include individuals with all loci and loci found in all individuals. Now going to implement a strict HWE filter - if a locus is out of HWE in any population (hwe_facets = \"pop\") after a Bonferroni correction, then it will be removed. Also going to remove non-variant loci, and loci with only a single minor allele (“singletons”).\n\necor_snps <- filter_snps(ecor_snps, min_ind = 0.9999, min_loci = 0.9999, re_run = \"full\", \n                         hwe = 0.05, fwe_method = \"BY\", hwe_facets = \"pop\", singletons = T,\n                         verbose = T)\n\nInitializing...\nFiltering loci. Starting loci: 929 \nFiltering non-biallelic loci...\n    0 bad loci\nFiltering non_polymorphic loci...\n    0 bad loci\nFiltering loci sequenced in few individuals...\n    0 bad loci\nFiltering singletons.\n    521 bad loci\nFiltering loci out of hwe...\n     7  bad loci\n    Ending loci: 401 \nFiltering individuals. Starting individuals: 60 \nFiltering out individuals sequenced in few kept loci...\nNo individuals removed.\n\n\n\n\nIndividual Stats\nsnpR uses facets to subset data on either sample metadata (such as sample ID, or population) or SNP metadata. Here we will look at per-individual stats. Also, note that the calculations are just attached to the data object, so we don’t lose track of them. Nice.\n\necor_snps <- calc_hs(ecor_snps, facets = \"sampID\")\necor_snps <- calc_he(ecor_snps, facets = \"sampID\")\necor_snps <- calc_ho(ecor_snps, facets = \"sampID\")\n\n# and dang, just like that we can get a PCA\np <- plot_clusters(ecor_snps, facets = \"pop\")\n\nFormatting data...\n\np$plots$pca\n\n\n\n\nso there’s that one weirdo at Johnston, who is A150… we can identify him like this. He has double the mean \\(H_e\\) and \\(H_o\\).\n\necor_snps <- calc_genetic_distances(ecor_snps, facets = \"sampID\",method = \"Nei\")\nstats.ind <- get.snpR.stats(ecor_snps, facets=\"sampID\", stats = c(\"hs\",\"ho\",\"he\"))\nind.dists <- get.snpR.stats(ecor_snps,facets=\"sampID\", stats = \"genetic_distance\")                  \nheatmap(as.matrix(ind.dists$sampID$.base$Nei))\n\n\n\n# drop'im\necor_snps <- ecor_snps[,-which(\"Etelis_A150\" %in% names(ecor_snps))]\n\np2 <- plot_clusters(ecor_snps, facets = \"pop\")\n\nFormatting data...\n\np2$plots$pca\n\n\n\n\n\n\n\nRe-running after dropping the Bad Apple\nI went back to re-run populations from the stacks pipeline with the “Bad Apple” (sample A150 from Johnston) removed from the popmap (see above). This removal is as suggested by (Cerca et al. 2021) Now to re-do everything.\n\n\nAdegenet\nI am testing differences among 4 a priori defined populations. Thus, following recommendations in (thiaGuidelinesStandardizingApplication?), I will only use k-1 or 3 PCA axes.\n\necor_haps <- read.genepop(\"coruscans/populations_r100.dropA150/populations.haps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Stacks v2.61; GenePop v4.1.3; November 09, 2022 \n\n...done.\n\nlevels(ecor_haps$pop) <- c(\"JA\",\"MHI\",\"NWHI\",\"JP\")\n\necor_dapc_haps <- dapc(ecor_haps,pop =  ecor_haps$pop, scale = T, pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecor_dapc_haps)\n\n\n\necor_hwe <- hw.test(ecor_haps, B = 1000)\n\n# playing with cross-validation\n#xvalDapc(ecor_haps, grp = ecor_haps$pop, result = \"overall\", n.pca.max = 10, training.set = 0.75)\n\nLet’s take a look with the randomly selected SNPs\n\necor_snps.genind <- read.genepop(\"coruscans/populations_r100/populations.randsnp.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  # Stacks v2.61; GenePop v4.1.3; September 30, 2022 \n\n...done.\n\nlevels(ecor_snps.genind$pop) <- c(\"JA\",\"MHI\",\"NWHI\",\"JP\")\n\necor_dapc_snps <- dapc(ecor_snps.genind,pop =  ecor_snps.genind$pop, scale = T,\n                       pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecor_dapc_snps)\n\n\n\n\n\n\nSNPr\n\npopmap_cor <- read_tsv(\"coruscans/popmapECO.dropA150.tsv\",col_names = c(\"sampID\",\"pop\"))\n\nRows: 59 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): sampID, pop\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\necor_snps <- read_vcf(file = \"coruscans/populations_r100.dropA150/populations.randsnp.vcf\",\n                      sample.meta = popmap_cor)\n\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 14\n  header_line: 15\n  variant count: 984\n  column count: 68\n\nMeta line 14 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 984\n  Character matrix gt cols: 68\n  skip: 0\n  nrows: 984\n  row_num: 0\n\nProcessed variant: 984\nAll variants processed\n\n\n\nFiltering\nI’ve already implemented stringent filters in Stacks to only include individuals with all loci and loci found in all individuals. Now going to implement a strict HWE filter - if a locus is out of HWE in any population (hwe_facets = \"pop\") after a Bonferroni correction, then it will be removed. Also going to remove non-variant loci, and loci with only a single minor allele (“singletons”).\n\necor_snps <- filter_snps(ecor_snps, min_ind = 0.9999, min_loci = 0.9999, re_run = \"full\", \n                         hwe = 0.05, fwe_method = \"BY\", hwe_facets = \"pop\", singletons = T,\n                         verbose = T)\n\nInitializing...\nFiltering loci. Starting loci: 984 \nFiltering non-biallelic loci...\n    0 bad loci\nFiltering non_polymorphic loci...\n    0 bad loci\nFiltering loci sequenced in few individuals...\n    0 bad loci\nFiltering singletons.\n    538 bad loci\nFiltering loci out of hwe...\n     6  bad loci\n    Ending loci: 440 \nFiltering individuals. Starting individuals: 59 \nFiltering out individuals sequenced in few kept loci...\nNo individuals removed.\n\n\n\n\nIndividual Stats\nsnpR uses facets to subset data on either sample metadata (such as sample ID, or population) or SNP metadata. Here we will look at per-individual stats. Also, note that the calculations are just attached to the data object, so we don’t lose track of them. Nice.\n\necor_snps <- calc_hs(ecor_snps, facets = \"sampID\")\necor_snps <- calc_he(ecor_snps, facets = \"sampID\")\necor_snps <- calc_ho(ecor_snps, facets = \"sampID\")\n\n# and dang, just like that we can get a PCA\np <- plot_clusters(ecor_snps, facets = \"pop\")\n\nFormatting data...\n\np$plots$pca\n\n\n\n\n\n\nPopulation Stats\nAnd here are some summary stats about each population\n\necor_snps <- calc_ho(ecor_snps, facets = \"pop\")\necor_snps <- calc_he(ecor_snps, facets = \"pop\")\necor_snps <- calc_maf(ecor_snps, facets = \"pop\")\necor_snps <- calc_pi(ecor_snps, facets = \"pop\")\necor_snps <- calc_private(ecor_snps, facets = \"pop\")\necor_snps <- calc_hwe(ecor_snps, facets = \"pop\")\necor_snps <- calc_fis(ecor_snps, facets = \"pop\")\necor_snps <- calc_pairwise_fst(ecor_snps, facets = \"pop\",boot = 1000, boot_par = 5)\n\nstats <- get.snpR.stats(ecor_snps, facets = \"pop\", stats = c(\"maf\", \"ho\",\"he\",\"hwe\", \"fis\",\"pi\", \"private\"))\nstats$weighted.means\n\n\n\n  \n\n\n# and here is Fst\n\necor_fst <- get.snpR.stats(ecor_snps, facets = \"pop\", stats = c(\"fst\"))\necor_fst$fst.matrix\n\n$pop\n$pop$fst\n               p1 Johnston_Atoll          MHI          NWHI\n1:          Japan   -0.003445356  0.004937154  0.0032788133\n2: Johnston_Atoll             NA -0.011144848 -0.0212128337\n3:            MHI             NA           NA -0.0009330938\n\n$pop$p\n               p1 Johnston_Atoll       MHI      NWHI\n1:          Japan      0.3606394 0.1358641 0.1948052\n2: Johnston_Atoll             NA 0.6013986 0.7982018\n3:            MHI             NA        NA 0.4945055\n\n\n\n\nLinkage Disequilibrium\nA little stuck on LD. But there are so few markers (intentionally) that it really shouldn’t be an issue.\n\necor_snps <- calc_pairwise_ld(ecor_snps, facets =\"CHROM\", verbose = T)\nldstats <- get.snpR.stats(ecor_snps, stats = \"ld\", facets = \"CHROM\")\nld <- plot_pairwise_ld_heatmap(ecor_snps, facets=c(\"CHROM\"))\n\n\n\n\nRemove loci under selection using pcadapt\nFollowing along [here](https://bcm-uga.github.io/pcadapt/articles/pcadapt.html.\nFirst, write out the data into plink format\n\nformat_snps(ecor_snps, output = \"plink\", facets = \"pop\", \n            outfile = \"coruscans/plink/coruscans.plink\",chr = \"CHROM\", \n            position = \"position\" )\n\n\nScree Plot\n\necor_plink <- read.pcadapt(\"coruscans/plink/coruscans.plink.bed\",type=\"bed\")\n\npca20 <- pcadapt(ecor_plink, K = 20)\n\nplot(pca20, option = \"screeplot\")\n\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the pcadapt package.\n  Please report the issue at <\u001b]8;;https://github.com/bcm-uga/pcadapt/issues\u0007https://github.com/bcm-uga/pcadapt/issues\u001b]8;;\u0007>.\n\n\n\n\n\nBased on the scree plot I think we’ll use 6 PCs.\n\n\nPCA\n\npca6 <- pcadapt(ecor_plink, K = 6)\nplot(pca6, option = \"scores\", pop = popmap_cor$pop)\n\nWarning: Use of `df$Pop` is discouraged.\nℹ Use `Pop` instead.\n\n\n\n\n\n\nplot(pca6, option = \"manhattan\")\n\n\n\n#qqplot\nplot(pca6, option = \"qqplot\")\n\n\n\n#histogram\nhist(pca6$pvalues, xlab = \"p-values\", main = NULL, breaks = 50, col = \"orange\")\n\n\n\n\n\n\nOutliers\nSo the p-values (even uncorrected) are all fairly large here. There aren’t really any outliers.\n\npadj <- p.adjust(pca6$pvalues, method = \"BY\")\nalpha <- 0.001\npca6_outliers <- which(padj < alpha)\n\n#remove outliers\n#ecor_snps2 <- ecor_snps[-pca5_outliers,]\n\n\n\nWrite out filtered SNPs and haplotypes\n\n#write to vcf\nformat_snps(ecor_snps, output = \"vcf\", facets = \"pop\", \n            outfile = \"coruscans/hwe.pcadapt.filtered.snps.vcf\",chr = \"CHROM\", \n            position = \"position\" )\nformat_snps(ecor_snps, output = \"genepop\", facets = \"pop\", \n            outfile = \"coruscans/hwe.pcadapt.filtered.snps.gen\",chr = \"CHROM\", \n            position = \"position\" )\n\n#grab the locus names and write them to a whitelist to be included in the migrate data file.\nwhitelist <- ecor_snps@snp.meta$CHROM\nwrite.table(sort(as.numeric(ecor_snps@snp.meta$CHROM)), \"coruscans/ecor_whitelist.txt\", quote=F, row.names = F,col.names =F )\n\necor_haps2 <- ecor_haps[,loc = locNames(ecor_haps) %in% whitelist]\n# write them out\ngenind_to_genepop(ecor_haps2,output = \"coruscans/hwe.pcadapt.filtered.haps.txt\")\n\n\n\nRe-check the DAPC\nWe didn’t remove any outlier loci, so no need to re-calculate Fst.\n\nHaplotypes\n\necor_haps2 <- read.genepop(\"coruscans/hwe.pcadapt.filtered.haps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Conversion of an object of class 'genind' into a GENEPOP file with the package 'graph4lg'                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n\n...done.\n\nlevels(ecor_haps2$pop) <- c(\"JA\",\"JP\", \"MHI\",\"NWHI\")\n\necor_dapc2 <- dapc(ecor_haps2,pop =  ecor_haps2$pop, scale = T, pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nscatter(ecor_dapc2)\n\n\n\n\n\n\nSNPs\n\necor_snps2.genind <- read.genepop(\"coruscans/hwe.pcadapt.filtered.snps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  coruscans/hwe_genepop \n\n...done.\n\nlevels(ecor_snps2.genind$pop) <- c(\"JP\",\"JA\",\"MHI\",\"NWHI\")\n\necor_dapc2_snps <- dapc(ecor_snps2.genind,pop =  ecor_snps2.genind$pop, scale = T,\n                       pca.select=\"nbEig\", n.pca = 3, n.da=3)\n\nscatter(ecor_dapc2_snps)"
  },
  {
    "objectID": "Etelis_migrate.html#e.-carbunculus-2",
    "href": "Etelis_migrate.html#e.-carbunculus-2",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "E. carbunculus",
    "text": "E. carbunculus\n\nAdegenet\n\necar_haps <- read.genepop(\"carbunculus/populations_r100/populations.haps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Stacks v2.61; GenePop v4.1.3; September 30, 2022 \n\n...done.\n\nlevels(ecar_haps$pop) <- c(\"JP\",\"MHI\",\"NWHI\")\n\necar_dapc <- dapc(ecar_haps,pop =  ecar_haps$pop, scale = T, pca.select=\"nbEig\", n.pca = 2, n.da=2)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecar_dapc)\n\n\n\n\nLet’s take a look with the randomly selected SNPs\n\necar_snps.genind <- read.genepop(\"carbunculus/populations_r100/populations.randsnp.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  # Stacks v2.61; GenePop v4.1.3; September 30, 2022 \n\n...done.\n\nlevels(ecar_snps.genind$pop) <- c(\"JP\",\"MHI\",\"NWHI\")\n\necar_dapc_snps <- dapc(ecar_snps.genind,pop =  ecar_snps.genind$pop, scale = T,\n                       pca.select=\"nbEig\", n.pca = 2, n.da=2)\n\nWarning in .local(x, ...): Some scaling values are null.\n Corresponding alleles are removed.\n\nscatter(ecar_dapc_snps)\n\n\n\n\n\n\nSNPr\nI will use Will Hemstrom’s new package SNPr to further evaluate and filter the SNPs that I randomly selected from each locus.\n\necar_popmap <- read_tsv(\"carbunculus/popmapECA.tsv\",col_names = c(\"sampID\",\"pop\"))\n\nRows: 55 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): sampID, pop\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\necar_snps <- read_vcf(file = \"carbunculus/populations_r100/populations.randsnp.vcf\",\n                      sample.meta = ecar_popmap)\n\nScanning file to determine attributes.\nFile attributes:\n  meta lines: 14\n  header_line: 15\n  variant count: 2750\n  column count: 64\n\nMeta line 14 read in.\nAll meta lines processed.\ngt matrix initialized.\nCharacter matrix gt created.\n  Character matrix gt rows: 2750\n  Character matrix gt cols: 64\n  skip: 0\n  nrows: 2750\n  row_num: 0\n\nProcessed variant 1000\nProcessed variant 2000\nProcessed variant: 2750\nAll variants processed\n\n\n\nFiltering\nI’ve already implemented stringent filters in Stacks to only include individuals with all loci and loci found in all individuals. Now going to implement a strict HWE filter - if a locus is out of HWE in any population (hwe_facets = \"pop\") after a Bonferroni correction, then it will be removed. Also going to remove non-variant loci, and loci with only a single minor allele (“singletons”).\n\necar_snps <- filter_snps(ecar_snps, min_ind = 0.9999, min_loci = 0.9999, re_run = \"full\", \n                         hwe = 0.05, fwe_method = \"BY\", hwe_facets = \"pop\", singletons = T,\n                         verbose = T)\n\nInitializing...\nFiltering loci. Starting loci: 2750 \nFiltering non-biallelic loci...\n    0 bad loci\nFiltering non_polymorphic loci...\n    0 bad loci\nFiltering loci sequenced in few individuals...\n    0 bad loci\nFiltering singletons.\n    1064 bad loci\nFiltering loci out of hwe...\n     20  bad loci\n    Ending loci: 1666 \nFiltering individuals. Starting individuals: 55 \nFiltering out individuals sequenced in few kept loci...\nNo individuals removed.\n\n\n\n\nIndividual Stats\nsnpR uses facets to subset data on either sample metadata (such as sample ID, or population) or SNP metadata. Here we will look at per-individual stats. Also, note that the calculations are just attached to the data object, so we don’t lose track of them. Nice.\n\necar_snps <- calc_hs(ecar_snps, facets = \"sampID\")\necar_snps <- calc_he(ecar_snps, facets = \"sampID\")\necar_snps <- calc_ho(ecar_snps, facets = \"sampID\")\n\n# and dang, just like that we can get a PCA\np <- plot_clusters(ecar_snps, facets = \"pop\")\n\nFormatting data...\n\np$plots$pca\n\n\n\n\nThe separation between both Hawaiian populations and Japan is pretty evident even in the PCA.\n\necar_snps <- calc_genetic_distances(ecar_snps, facets = \"sampID\",method = \"Nei\")\nstats.ind <- get.snpR.stats(ecar_snps, facets=\"sampID\", stats = c(\"hs\",\"ho\",\"he\"))\nind.dists <- get.snpR.stats(ecar_snps,facets=\"sampID\", stats = \"genetic_distance\")                  \nheatmap(as.matrix(ind.dists$sampID$.base$Nei))\n\n\n\n\nAnd there doesn’t seem to be any reason to drop any individuals.\n\n\nPopulation Stats\nAnd here are some summary stats about each population\n\necar_snps <- calc_ho(ecar_snps, facets = \"pop\")\necar_snps <- calc_he(ecar_snps, facets = \"pop\")\necar_snps <- calc_maf(ecar_snps, facets = \"pop\")\necar_snps <- calc_pi(ecar_snps, facets = \"pop\")\necar_snps <- calc_private(ecar_snps, facets = \"pop\")\necar_snps <- calc_hwe(ecar_snps, facets = \"pop\")\necar_snps <- calc_fis(ecar_snps, facets = \"pop\")\necar_snps <- calc_pairwise_fst(ecar_snps, facets = \"pop\", boot = 1000, boot_par = 5)\n\nstats <- get.snpR.stats(ecar_snps, facets = \"pop\", stats = c(\"maf\", \"ho\",\"he\",\"hwe\", \"fis\",\"pi\", \"private\"))\nstats$weighted.means\n\n\n\n  \n\n\n# and here is Fst\n\necar_fst <- get.snpR.stats(ecar_snps, facets = \"pop\", stats = c(\"fst\"))\necar_fst$fst.matrix\n\n$pop\n$pop$fst\n      p1        MHI        NWHI\n1: Japan 0.01746465 0.021466084\n2:   MHI         NA 0.001113613\n\n$pop$p\n      p1         MHI        NWHI\n1: Japan 0.002997003 0.000999001\n2:   MHI          NA 0.328671329\n\n\n\n\nLinkage Disequilibrium\nA little stuck on LD. But there are so few markers (intentionally) that it really shouldn’t be an issue.\n\necar_snps <- calc_pairwise_ld(ecar_snps, facets =\"CHROM\", verbose = T)\nldstats <- get.snpR.stats(ecar_snps, stats = \"ld\", facets = \"CHROM\")\nld <- plot_pairwise_ld_heatmap(ecar_snps, facets=c(\"CHROM\"))\n\n\n\n\nRemove loci under selection using pcadapt\nFollowing along [here](https://bcm-uga.github.io/pcadapt/articles/pcadapt.html.\nFirst, write out the data into plink format\n\nformat_snps(ecar_snps, output = \"plink\", facets = \"pop\", \n            outfile = \"carbunculus/plink/carbunculus.plink\",chr = \"CHROM\", \n            position = \"position\" )\n\n\nScree Plot\n\necar_plink <- read.pcadapt(\"carbunculus/plink/carbunculus.plink.bed\",type=\"bed\")\n\npca20 <- pcadapt(ecar_plink, K = 20)\n\nplot(pca20, option = \"screeplot\")\n\n\n\n\nBased on the scree plot I think we’ll use 2 PCs.\n\n\nPCA\n\npca2 <- pcadapt(ecar_plink, K = 2)\nplot(pca2, option = \"scores\", pop = ecar_popmap$pop)\n\nWarning: Use of `df$Pop` is discouraged.\nℹ Use `Pop` instead.\n\n\n\n\n\n\nplot(pca2, option = \"manhattan\")\n\n\n\n#qqplot\nplot(pca2, option = \"qqplot\")\n\n\n\n#histogram\nhist(pca2$pvalues, xlab = \"p-values\", main = NULL, breaks = 50, col = \"orange\")\n\n\n\n\n\n\nOutliers\nIn this species, there are some clear outliers. I am going to correct to Benjamini-Yekuteli False Discovery Rate, with a 1 in 1000 FDR.\n\npadj <- p.adjust(pca2$pvalues, method = \"BY\")\nalpha <- 0.001\npca2_outliers <- which(padj < alpha)\n\n#remove outliers\necar_snps2 <- ecar_snps[-pca2_outliers,]\n\n\n\nWrite out filtered SNPs and haplotypes\nI’m going to write a whitelist with 401 randomly selected SNPs - to be in parity with coruscans. Adding more would take longer.\n\n#write to vcf\nformat_snps(ecar_snps2, output = \"vcf\", facets = \"pop\", \n            outfile = \"carbunculus/hwe.pcadapt.filtered.snps.vcf\",chr = \"CHROM\", \n            position = \"position\" )\n\nformat_snps(ecar_snps2, output = \"genepop\", facets = \"pop\", \n            outfile = \"carbunculus/hwe.pcadapt.filtered.snps.genepop\",chr = \"CHROM\", \n            position = \"position\" )\n\nwrite.csv(pca2_outliers, \"carbunculus/pcadapt.outliers.csv\")\n#grab the locus names, pick a random subset of 1000, and write them to a whitelist to be included in the migrate data file.\nwhitelist <- ecar_snps2@snp.meta$CHROM[sample(1:nsnps(ecar_snps2),1000)]\nwrite.table(sort(as.numeric(whitelist)), \n            \"carbunculus/ecar_whitelist.txt\", quote=F, row.names = F,col.names =F )\n\necar_haps2 <- ecar_haps[,loc = locNames(ecar_haps) %in% whitelist]\n# write them out\ngenind_to_genepop(ecar_haps2,output = \"carbunculus/hwe.pcadapt.filtered.haps.txt\")\n\necar_snps3 <- ecar_snps2[ecar_snps2@snp.meta$CHROM %in% whitelist,]\nformat_snps(ecar_snps3, output = \"genepop\", facets = \"pop\", \n            outfile = \"carbunculus/hwe.pcadapt.filtered.snps1000.genepop\",chr = \"CHROM\", \n            position = \"position\" )\n\n\n\nRe-check the DAPC\n\nHaplotypes\n\necar_haps2 <- read.genepop(\"carbunculus/hwe.pcadapt.filtered.haps.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  Conversion of an object of class 'genind' into a GENEPOP file with the package 'graph4lg'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n\n...done.\n\nlevels(ecar_haps2$pop) <- c(\"JP\",\"MHI\",\"NWHI\")\n\necar_dapc2 <- dapc(ecar_haps2,pop =  ecar_haps2$pop, scale = T, pca.select=\"nbEig\", n.pca = 2, n.da=2)\n\nscatter(ecar_dapc2)\n\n\n\n\n\n\nSNPs\n\necar_snps2.genind <- read.genepop(\"carbunculus/hwe.pcadapt.filtered.snps1000.gen\")\n\n\n Converting data from a Genepop .gen file to a genind object... \n\n\nFile description:  carbunculus/hwe_genepop \n\n...done.\n\nlevels(ecar_snps2.genind$pop) <- c(\"JP\",\"MHI\",\"NWHI\")\n\necar_dapc2_snps <- dapc(ecar_snps2.genind,pop =  ecar_snps2.genind$pop, scale = T,\n                       pca.select=\"nbEig\", n.pca = 2, n.da=2)\n\nscatter(ecar_dapc2_snps)\n\n\n\n\nSo the structure as depicted by DAPC still seems intact in this species.\n\npopmap2 <- tibble(pop=c(rep(\"Japan\",14),rep(\"MHI\",14),rep(\"NWHI\",27)))\necar_snps3 <- read_genepop(file = \"carbunculus/hwe.pcadapt.filtered.snps.genepop\",sample.meta = popmap2)\n\nWarning in .sub_and_t_1_2_to_A_C(ac, ncol(gt)): Since allelic identities are not clear, alleles at each locus will be saved as A and C. If this data is later reformatted for use elsewhere, please be aware that this may cause issues for some downstream analyses (since, for example, all SNPs will be nonsensically noted as transversions rather than transitions!).\n To prevent this, use a different format that specifies allelic identities.\nThis is not an issue for any snpR functions save those that rely on ancestral/derived allelic identities.\n\n\nWarning in validityMethod(object): Some snp metadata columns contain unacceptable special characters. Unaccepted characters: '.', '~', or any whitespace.\nThese can cause unexpected behaviour if the subect columns are used as facets.\n\necar_snps3 <- calc_ho(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_he(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_maf(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_pi(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_private(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_hwe(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_fis(ecar_snps3, facets = \"pop\")\necar_snps3 <- calc_pairwise_fst(ecar_snps3, facets = \"pop\", boot= 1000, boot_par = 5)\n\nstats <- get.snpR.stats(ecar_snps3, facets = \"pop\", stats = c(\"maf\", \"ho\",\"he\",\"hwe\", \"fis\",\"pi\", \"private\"))\nstats$weighted.means\n\n\n\n  \n\n\n# and here is Fst\n\necar_fst3 <- get.snpR.stats(ecar_snps3, facets = \"pop\", stats = c(\"fst\"))\necar_fst3$fst.matrix\n\n$pop\n$pop$fst\n      p1        MHI         NWHI\n1: Japan 0.01413796 0.0165854943\n2:   MHI         NA 0.0003387499\n\n$pop$p\n      p1        MHI        NWHI\n1: Japan 0.01198801 0.000999001\n2:   MHI         NA 0.411588412\n\n\nAnd compare that to pre-filtering. Some differences, but not as much as when I was overly stringent with selected loci.\n\necar_fst$fst.matrix\n\n$pop\n$pop$fst\n      p1        MHI        NWHI\n1: Japan 0.01746465 0.021466084\n2:   MHI         NA 0.001113613\n\n$pop$p\n      p1         MHI        NWHI\n1: Japan 0.002997003 0.000999001\n2:   MHI          NA 0.328671329"
  },
  {
    "objectID": "Etelis_migrate.html#install-python2",
    "href": "Etelis_migrate.html#install-python2",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Install Python2",
    "text": "Install Python2\nI had a doozy of a time trying to get this to work this time around: the script was written in python2. which is nearly deprecated. I first tried to use 2to3 to upgrade the script to python3, but there were a few stray tabs I couldn’t figure out. I eventually landed here, and used the following commands to install pyenv, which can handle multiple python installs.\n\nbrew install pyenv\npyenv install 2.7.18\npyenv versions\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc\\necho 'command -v pyenv >/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc\\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\nexec \"$SHELL\"\npyenv shell 2.7.18 # use python 2 for this shell session\n\n pip install numpy\n pip install --upgrade pip # need to update pip to be able to install scipy\n pip install scipy"
  },
  {
    "objectID": "Etelis_migrate.html#e.-coruscans-3",
    "href": "Etelis_migrate.html#e.-coruscans-3",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "E. coruscans",
    "text": "E. coruscans\n\nRun it\nI had to remove all the [individualName] tokens from the populations.samples.fa to get it to work. Also, I added a SampleID column and header row to the popmap for use by fasta2genotype.py. I wrote out a whitelist above of all the 440 loci that passed through the filters.\n\npython ../../fasta2genotype/fasta2genotype.py populations_r100.dropA150/populations.samples2.fa ecor_whitelist.txt \\\npopmapECO_f2g.tsv NA Ecoruscans440.mig\n\n\n###################################################################\n###                                                             ###\n###       Fasta2Genotype | Data Conversion | Version 1.10       ###\n###                                                             ###\n###                        Cite as follows:                     ###\n###                                                             ###\n###   Maier P.A., Vandergast A.G., Ostoja S.M., Aguilar A.,     ###\n###   Bohonak A.J. (2019). Pleistocene glacial cycles drove     ###\n###   lineage diversification and fusion in the Yosemite toad   ###\n###   (Anaxyrus canorus). Evolution, in press.                  ###\n###   https://www.doi.org/10.1111/evo.13868                     ###\n###                                                             ###\n###################################################################\n\nOutput type? [1] Migrate [2] Arlequin [3] DIYABC [4] LFMM [5] Phylip [6] G-Phocs [7] Treemix [8] Haplotype: 1\nLoci to use? [1] Whitelist [2] All: 1\nRemove restriction enzyme or adapter sequences? These may bias data. [1] Yes [2] No: 2\nRemove monomorphic loci? [1] Yes [2] No: 1\nRemove loci with excess heterozygosity? This can remove paralogs. [1] Yes [2] No: 1\nMaximum heterozygosity cutoff for removing loci out of Hardy-Weinberg? 0.5\nFilter for allele frequency? False alleles might bias data. [1] Yes [2] No: 2\nFilter for missing genotypes? These might bias data. [1] Yes [2] No: 2\n \n**************************************************************************************************************\n***                                       ... BEGINNING CONVERSION ...                                     ***\n**************************************************************************************************************\n \nCataloging loci...\nCounting locus lengths...\nCataloging populations...\nCounting gene copies...\nCounting alleles for each locus...\nIdentifying loci with excess heterozygosity...\n     Calculating observed heterozygosity and homozygosity...\n     Calculating expected heterozygosity and homozygosity...\n     Flagging loci with excess heterozygosity for removal...\n     Removing loci...\n     Removed 1 overly heterozygous loci.\nOutputting migrate-n file...\n\n\n# it removed locus 60082 for excess heterozygosity, so I dropped it from the whitelist.\n\nI then re-ran the script, selecting phylip output, with locus name headers, and all other options the same. I need the locus names in the order output by the script in order to run modeltest."
  },
  {
    "objectID": "Etelis_migrate.html#e.-carbunculus-3",
    "href": "Etelis_migrate.html#e.-carbunculus-3",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "E. carbunculus",
    "text": "E. carbunculus\n\nRun it\nI had to remove all the [individualName] tokens from the populations.samples.fa to get it to work. Also, I added a SampleID column and header row to the popmap for use by fasta2genotype.py. I wrote out a whitelist above of 1000/1666 randomly selected loci that passed through the filters. Used the same options as E. coruscans.\n\npython ../../fasta2genotype/fasta2genotype.py populations_r100/populations.samples2.fa ecar_whitelist_1000.txt \\\npopmapECA_f2g.tsv NA Ecarbunculus999.mig\n\nOutput type? [1] Migrate [2] Arlequin [3] DIYABC [4] LFMM [5] Phylip [6] G-Phocs [7] Treemix [8] Haplotype: 1\nLoci to use? [1] Whitelist [2] All: 1\nRemove restriction enzyme or adapter sequences? These may bias data. [1] Yes [2] No: 2\nRemove monomorphic loci? [1] Yes [2] No: 1\nRemove loci with excess heterozygosity? This can remove paralogs. [1] Yes [2] No: 1\nMaximum heterozygosity cutoff for removing loci out of Hardy-Weinberg? 0.5\nFilter for allele frequency? False alleles might bias data. [1] Yes [2] No: 2\nFilter for missing genotypes? These might bias data. [1] Yes [2] No: 2\n \n**************************************************************************************************************\n***                                       ... BEGINNING CONVERSION ...                                     ***\n**************************************************************************************************************\n \nCataloging loci...\nCounting locus lengths...\nCataloging populations...\nCounting gene copies...\nCounting alleles for each locus...\nIdentifying loci with excess heterozygosity...\n     Calculating observed heterozygosity and homozygosity...\n     Calculating expected heterozygosity and homozygosity...\n     Flagging loci with excess heterozygosity for removal...\n     Removing loci...\n     Removed 1 overly heterozygous loci.\nOutputting migrate-n file...\n*** DONE! ***\n\n\nIt removed locus 31718 for being overly heterozygous, so I zapped it from the whitelist.\n\nI then re-ran the script, selecting phylip output, with full sequences, haploid, all loci, not separated by ! locus name headers, and all other options the same. I need the locus names in the order output by the script in order to run modeltest. This is only needed to get the locus names in the next step."
  },
  {
    "objectID": "Etelis_migrate.html#mutation-models-code-used-for-both-species",
    "href": "Etelis_migrate.html#mutation-models-code-used-for-both-species",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Mutation Models (code used for both species)",
    "text": "Mutation Models (code used for both species)\nI need to figure out an overall mutation model to use with RAD loci. I received this advice one from Peter about how to construct these. I’ll use modelTest in the phangorn package to see where that gets me.\nI renamed the FASTA headers in populations.samples.fa with BBEdit to create population.samples3.fa\n\nFind: >CLocus_\\d+_Sample_\\d+_Locus_(\\d+)_Allele_([01]) \\[Etelis_(.+)\\]\nReplace: >\\3_L\\1_A\\2\n\n#first token is sample name, second is locus number(name) third is allele\n\n#Also remove bad indiv A150 in coruscans\nFind: >A150_.+\\n.+\\n\nReplace:\n\nLets load in the data and calculate some statistics for each locus. Previously Migrate-n only implemented the F84 (=HKY) model, with two rates (Transitions and Transversions) and gamma distributed rate variability.\nNow it will take these possible models: 1 Jukes-Cantor model 2 Kimura 2-parameter model 3 Felsenstein 1981 (F81) model 4 Felsenstein 1984 (F84) model 5 Hasegawa-Kishino-Yano model 6 Tamura-Nei model\n\nfastadata <- read.FASTA(\"coruscans/populations_r100.dropA150//populations.samples3.fa\")\n\n#  read in the locus lengths, as optional additional way to make sure the stats\n# and the migrate infile are ordered the same\n#migrate_lengths <- read_lines(\"coruscans/Ecoruscans.mig\", skip = 1, n_max=1) %>% \n#  str_split(\"\\\\t\", simplify = T) %>%  t(.) %>% tibble(length=.) %>% na.omit()\n\nmigrate_loci <- read_lines(\"coruscans/Ecoruscans439.phy\", skip = 1, n_max=1) %>% \n  str_split(\"\\\\t\", simplify = T) %>%  t(.) %>% tibble(locus_name=.) %>% filter(locus_name!=\"\")\n\nstats <- tibble(locus = character(), \n                length = numeric(),\n                segSites = numeric(),\n                nHaps = numeric(),\n                nucDiv = numeric(),\n                ttRatio = numeric(),\n                model = character(),\n                gammaShape = numeric(),\n                rate1 = numeric(), \n                rate2 = numeric(), \n                rate3 = numeric(),\n                rate4 = numeric(),\n                Q1= numeric(),\n                Q2 = numeric(),\n                Q3 = numeric(),\n                )\n                \nfor(l in migrate_loci$locus_name){\n  L <- paste0(\"L\",l,\"_\")\n  print(paste(\"Now Doing Locus\", l, match(l,  migrate_loci$locus_name), \"out of\", length(migrate_loci$locus_name)))\n  locus_dnabin <- fastadata[str_which(names(fastadata),pattern = L)]\n  # convert to package formats\n  locus_dnabin <- as.matrix(locus_dnabin)\n  locus_gtypes <- sequence2gtypes(locus_dnabin)\n  locus_phy <- phyDat(locus_dnabin)\n  #create a haplotype network .. to be continued\n  haps <- haplotype(locus_dnabin)\n  nhaps <- length(dimnames(haps)[[1]])\n  #tcs <- haploNet(haps)\n  #find parameters of HKY (F84) model\n  modeltest <- modelTest(locus_phy, model = c(\"JC\",\"K80\", \"F81\", \"HKY\",\"TrN\"), \n                         G = T, I = F, k = 4, mc.cores = 5)\n  # pick out the best model. If multiple models are tied for best, pick the simplest one\n  bestmodel <- modeltest$Model[which(modeltest$BIC == min(modeltest$BIC))][1]\n  #open the object environment\n  env <- attr(modeltest,\"env\")\n  bestparams <- get(bestmodel, env)\n  bestparams <- eval(bestparams, env=env)\n  # use this code for v3, which only has F84 (HKY)\n  #HKY <- modelTest(locus_phy, model = c(\"HKY\"), \n  #                       G = T, I = F, k = 4)\n  #env <- attr(HKY, \"env\")\n  #HKYG <- get(\"HKY+G\", env)\n  #model <- eval(HKYG, env=env)\n  # calculate TiTv Ratio\n  ttratio <- TiTvRatio(locus_gtypes)\n  \n  stats <- bind_rows(stats, tibble(locus=L, \n                          length = length(locus_dnabin[1,]),\n                          segSites = length(seg.sites(locus_dnabin)),\n                          nHaps = length(dimnames(haps)[[1]]),\n                          nucDiv = nuc.div(locus_dnabin),\n                          ttRatio =  ttratio[3],\n                          model = bestmodel,\n                          gammaShape = bestparams$shape,\n                          rate1 = bestparams$g[1],\n                          rate2 = bestparams$g[2],\n                          rate3 = bestparams$g[3],\n                          rate4 = bestparams$g[4],\n                          Q1 = sort(unique(bestparams$Q))[1],\n                          Q2 = sort(unique(bestparams$Q))[2],\n                          Q3 = sort(unique(bestparams$Q))[3]\n                          ))\n                         \n                        \n}\n\n#stats <- stats[which(stats$length %in% migrate_lengths$length),]\n#setdiff(stats$length, as.numeric(migrate_lengths$length))\n# write_csv(stats, \"coruscans/migrate_locus_statistics439.csv\")\n\n\nWrite a model block\nWrite a space delimited textfile that can be added to the migrate data file in the format that Peter suggested.\n\n#stats <- read_csv(\"./carbunculus/migrate_locus_statistics.csv\")\n#kable(stats)\n\n\n# write a space delimited textfile that can be added to the migrate data file\n# following Peter's suggestion here:\n#https://groups.google.com/g/migrate-support/c/XjV_4jZW4RI/m/HbRWoGY6AwAJ\nmigrate_mutation_models <- tibble(prefix = \"#$\",\n                                 locus=1:length(stats$locus),\n                                 type = \"s\",\n                                 model = stats$model,\n                                 q1 = stats$Q2,\n                                 q2 = stats$Q3)\n\n#write_delim(migrate_mutation_models,\"./coruscans/migrate_modelblock439.txt\", na=\"\", delim = \" \")\n\nRead them back in so we don’t have to recalculate them every time I knit.\nSo we have a 0 invariant loci, and the mean overall transition:transversion ratio is NaN. Mean gamma shape parameter is NA, which argues for only one rate."
  },
  {
    "objectID": "Etelis_migrate.html#metapopulation-models",
    "href": "Etelis_migrate.html#metapopulation-models",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Metapopulation Models",
    "text": "Metapopulation Models\nColumns = departure pop, Rows = arrival pop\n* = equilibrium gene flow/drift OR theta (\\(N_e\\mu\\)) parameter (on diagonal)\nd = divergence without gene flow\nD = divergence with gene flow\n0 = parameter not included in model\n\nE. coruscans\n\ndivergence_geneflow_1\nJA    * 0   0   0\nJO    D *   0   0\nMHI   0 D   *   0\nNWHI  0 0   D   *\n\n\n\ndivergence_geneflow_2\n*   0   0   0\nD   *   0   0\n0   0   *   D\n0   D   0   *\n\n\ndivergence_geneflow_3\n*   0   0   0\n0   *   0   D\n0   0   *   D\nD   0   0   *\n\n\ndivergence_only_1\n*   0   0   0\nd   *   0   0\n0   d   *   0\n0   0   d   *\n\n\ndivergence_only_2\n*   0   0   0\nd   *   0   0\n0   0   *   d\n0   d   0   *\n\n\ndivergence_only_3\n*   0   0   0\n0   *   0   d\n0   0   *   d\nd   0   0   *\n\n\ngeneflow_only_full\n*   *   *   *\n*   *   *   *\n*   *   *   *\n*   *   *   *\n\n\ngeneflow_only_1\n*   0   0   0\n*   *   0   0\n0   *   *   0\n0   0   *   *\n\n\ngeneflow_only_2\n*   0   0   0\n*   *   0   0\n0   0   *   *\n0   *   0   *\n\n\ngeneflow_only_3\n*   0   0   0\n0   *   0   *\n0   0   *   *\n*   0   0   *\n\n\nn-island\nm   m   m   m\nm   m   m   m\nm   m   m   m\nm   m   m   m\n\n\npanmixia\n*\n\n\npopulation-relabel={1 1 1 1}\n\n\n\nE. carbunculus\n\ndivergence_geneflow_1\nJA    * 0   0\nMHI   D *   0\nNWHI  0 D   *\n\n\n\ndivergence_geneflow_2\n*   0   0\n0   *   D\nD   0   *\n\n\ndivergence_only_1\n*   0   0\nd   *   0\n0   d   *\n\n\ndivergence_only_2\n*   0   0\n0   *   d\nd   0   *\n\n\ngeneflow_only_full\n*   0   0\n*   *   0\n0   *   *\n\n\ngeneflow_only_1\n*   0   0\n0   *   *\n*   0   *\n\n\ngeneflow_only_2\n*   *   *\n*   *   *\n*   *   *\n\n\nn-island\nm   m   m\nm   m   m\nm   m   m\n\n\npanmixia\n*\n\n\npopulation-relabel={1 1 1 1}"
  },
  {
    "objectID": "Etelis_migrate.html#parmfile",
    "href": "Etelis_migrate.html#parmfile",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Parmfile",
    "text": "Parmfile\nHere’s the parmfile I am using, based on my parmfile for Palythoa tuberculosa. This one depicts a model of divergence without gene flow. Migration prior is increased to have a maximum of 1e8 (100,000,000), and mean of 1e4 (10,000). This reflects a prior expectation that \\(m/\\mu\\) will not be larger than this value, if m is not larger than 0.1 (10% of population migrates), assuming a nuclear mutation rate of 1e-9. Also on average one out of every 100K individuals will send a migrant (m = 1e-5).\n\n################################################################################\n# Parmfile for Migrate 4.4.4(git:v4-series-26-ge85c6ff)-June-1-2019 [do not remove these first TWO lines]\n# generated automatically on\n# Fri Feb 4 2022\nmenu=NO\nnmlength=10\ndatatype=SequenceData\ndatamodel=HKY\nttratio=1.000000\n\nfreqs-from-data=YES \n\nseqerror-rate={0.0001,0.0001,0.0001,0.0001}\ncategories=1 #no categories file specified\nrates=1: 1.000000 \nprob-rates=1: 1.000000 \nautocorrelation=NO\nweights=NO\nrecover=NO\nfast-likelihood=NO\ninheritance-scalars={1.00000000000000000000}\nhaplotyping=YES:no-report\npopulation-relabel={1 2 3 4}\ninfile=../../Ecarbunculus.mig\nrandom-seed=AUTO #OWN:410568459\ntitle= Etelis coruscans\nprogress=YES\nlogfile=YES:logfile.txt\nprint-data=NO\noutfile=outfile.txt\npdf-outfile=outfile.pdf\npdf-terse=YES\nuse-M=YES\nprint-tree=NONE\nmig-histogram=MIGRATIONEVENTSONLY\nskyline=NO #needs mig-histogram=ALL:...\ntheta=PRIOR:50\nmigration=PRIOR:10\nrate=PRIOR:50\nsplit=PRIOR:10\nsplitstd=PRIOR:10\nmutation=CONSTANT\nanalyze-loci=A\ndivergence-distrib=E\ncustom-migration={\n*   0   0   0\nd   *   0   0\n0   d   *   0\n0 0 d *\n}\ngeo=NO\n\nupdatefreq=0.200000 0.200000 0.200000 0.200000 #tree, parameter haplotype, timeparam updates\nbayes-posteriorbins= 2000 2000\nbayes-posteriormaxtype=TOTAL\nbayes-file=YES:bayesfile\nbayes-allfile=YES:bayesallfile\nbayes-all-posteriors=YES:bayesallposterior\nbayes-proposals= THETA METROPOLIS-HASTINGS Sampler\nbayes-proposals= MIG SLICE Sampler\nbayes-proposals= DIVERGENCE METROPOLIS-HASTINGS Sampler\nbayes-proposals= DIVERGENCESTD METROPOLIS-HASTINGS Sampler\nbayes-priors= THETA WEXPPRIOR: 0.0 0.001 0.1000000 0.01000 \nbayes-priors= MIG WEXPPRIOR: 0.0100 10000.000000 100000000 10000\nbayes-priors= SPLIT * *  WEXPPRIOR: 0.0 0.001 0.1000000 0.01000\nbayes-priors= SPLITSTD * *  WEXPPRIOR: 0.0 0.001 0.1000000 0.01000\nbayes-hyperpriors=NO\nlong-chains=1\nlong-inc=100\nlong-sample=10000\nburn-in=2000  \nauto-tune=YES:0.440000\nassign=NO\nheating=YES:1:{1.000000,1.500000,3.000000,1000000.000000}\nheated-swap=YES\nmoving-steps=NO\ngelman-convergence=No\nreplicate=YES:3\nend\n\n\nCopy It Up\nCopy it up, and then make a total of 10 replicate copies of the folder.\n\nscp -r coruscans/migrate/rep_template eric@threadripper.tobolab.org:./Etelis/coruscans/rep1\nscp -r coruscans/Ecoruscans439.mig eric@threadripper.tobolab.org:./Etelis/coruscans/Ecoruscans2.mig\n\nscp -r carbunculus/migrate/rep_template eric@threadripper.tobolab.org:./Etelis/carbunculus/rep1\nscp -r carbunculus/Ecarbunculus999.mig eric@threadripper.tobolab.org:./Etelis/carbunculus/Ecarbunculus.mig\n\n#once on server, copy it 9 times\nfor a in $(seq 2 10); do cp -r rep1 rep$a; done"
  },
  {
    "objectID": "Etelis_migrate.html#bash-script",
    "href": "Etelis_migrate.html#bash-script",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Bash Script",
    "text": "Bash Script\nSo we will do 10 replicates of 3 replicates. This will start at r1, and run all models for that before moving on. Pretty sure this will finish one whole model before moving on to the next one (since all threads are being used for different loci). This uses two threads per core as well with the –use-hwthread-cpus flag.\n\n### Bash Script\n#!\nfor r in */\n        do\n                cd $r\n                echo $r\n                date\n                date > date.txt\n                        for m in */\n                          do\n                                cd $m\n                                  date > date.txt\n                                  echo $m\n                                  date\n                                  mpirun --use-hwthread-cpus -np 120 ~/migrate-5.0.4/src/migrate-n-mpi parmfile\n                                  sleep 1\n                                cd ..\n                          done\n                cd ..\n        done\n\nThe way that model marginal likelihood is calculated depends on the scaling constant k, which is an indicator of agreement on parameter values between loci. To get this, migrate uses the same histograms that it uses in its output. Thus, setting number of bins becomes important, as does using a version of migrate that doesn’t have the visualization issues that Peter reported. I revised my bash submission script to:\n\nmake a new copy of parmfile called parmfile_rerun\nchange recover=NO to recover=YES - this will make migrate summarize the current bayesallfile, rather than create a brand new run\nChange the number of bins from 3,000 to 2^14 = 16,384\nWrite the outfile to outfile_rerun.txt\nUse version 5.0.4 instead of 4.4.4 (which has viz problems)\n\n\nRe-running with more bins\n#| eval: false\n\n<!-- ### Bash Script -->\n<!-- #! -->\n<!-- for r in */ -->\n<!--    do -->\n<!--     echo starting $r at $(date ) >> progress_rerun.txt -->\n<!--          cd $r -->\n<!--        echo $r -->\n<!--        date -->\n<!--        echo starting $r at $(date ) >> progress_rerun.txt -->\n<!--            for m in */ -->\n<!--              do -->\n<!--              echo starting $m at $(date )>> progress_rerun.txt -->\n<!--                cd $m -->\n<!--                  date > date_rerun.txt -->\n<!--                  echo $m -->\n<!--                  date -->\n<!--                  # copy the parmfile to parmfile_rerun, and replace the following 3 lines -->\n<!--                  cp parmfile parmfile_rerun -->\n<!--                  sed -i 's/recover=NO/recover=YES/g' parmfile_rerun -->\n<!--                  sed -i 's/outfile=outfile.txt/outfile=outfile_rerun.txt/g' parmfile_rerun -->\n<!--                  sed -i 's/bayes-posteriorbins= 3000 3000/bayes-posteriorbins= 16384 16384/g' parmfile_rerun -->\n\n<!--                  mpirun --use-hwthread-cpus -np 60 ~/migrate-5.0.4/src/migrate-n-mpi parmfile_rerun -->\n<!--                  sleep 1 -->\n<!--                cd .. -->\n<!--              done -->\n<!--        cd .. -->\n<!--    done -->\n\n\nAnd back down\nAnd ten replicates finished in about 10 days! Found this guide to download everything except the massive bayesallfiles and pdfs\n\nrsync -av -e ssh --exclude='bayes*' --exclude=\"*.pdf\" --exclude=\"*.mig\" eric@threadripper.tobolab.org:~/Etelis/coruscans ./coruscans/migrate/output2\n\nrsync -av -e ssh --exclude='bayes*' --exclude=\"*.pdf\" --exclude=\"*.mig\" eric@moneta.tobolab.org:~/Etelis/coruscans ./coruscans/migrate/output\n\nrsync -av -e ssh --exclude='bayes*' --exclude=\"*.pdf\" --exclude=\"*.mig\" eric@threadripper.tobolab.org:~/Etelis/carbunculus ./carbunculus/migrate/output\n\n\n\nChecking the effects of a bad Ti/Tv ratio\nSo, I was using a Ti/Tv ratio in my K80/HKY mutation models that was way out of bounds. I’ve exported the locus-by-locus marginal likelihoods out of the panmixia, full and divergence-with-gene-flow3 models to see what happens when I remove the bad loci.\n\nmlikes <- read_csv(\"coruscans/model_marglike_comp.csv\") %>% \n            filter(!Locus_Index %in% badloci$Locus) %>%\n              filter(!Locus_Index==440) %>%  #locus 440 is the migrate sum\n              summarize(across(.fns = sum))\n\nmlikes\n\nWith this new back-of-the-envelope analysis, the full model comes 3rd, after divergence-with-gene-flow3. The scaling factor might have a big effect here."
  },
  {
    "objectID": "Etelis_migrate.html#results",
    "href": "Etelis_migrate.html#results",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Results",
    "text": "Results\n\nE. coruscans\n\nModel Marginal Likelihoods\n\nrunDir_cor <- \"coruscans/migrate/output5\"\n\nlikelist_cor <- list()\nfor(r in 1:5){\n  rep = paste0(\"rep\",r)\n  print(rep)\n  likelist_cor[[rep]] <- harvest.model.likelihoods(workingDir=file.path(runDir_cor,rep),\n                                                   outfileName = \"outfile_rerun3.txt\")\n}\n\n# Model selection for each replicate...\nlikelist_cor %>% map(bfcalcs)\n\nThe final model marginal likelihood estimates based on the mean of 10 replicates:\n\nlike.df_cor <-  likelist_cor %>% bind_rows() %>% group_by(model)\n\nmeans_cor <- like.df_cor %>% summarize(bezier.corrected = mean(bezier.corrected))\n  \n\nfinal_model_cor <- bfcalcs(means_cor)\n\nfinal_model_cor\n\n\n\n  \n\n\n\n\n\nT-Test\nDifference between panmixia and the second-place full model is very significant.\n\ntop.choice <- final_model_cor$model[which(final_model_cor$choice ==1)]\nsecond.choice <- final_model_cor$model[which(final_model_cor$choice ==2)]\n\npermTS(like.df_cor$bezier.corrected[which(like.df_cor$model == top.choice)],\n       like.df_cor$bezier.corrected[which(like.df_cor$model == second.choice)],\n       alternative = \"greater\", method = \"exact.ce\")\n\n\n    Exact Permutation Test (complete enumeration)\n\ndata:  GROUP 1 and GROUP 2\np-value = 0.003968\nalternative hypothesis: true mean GROUP 1 - mean GROUP 2 is greater than 0\nsample estimates:\nmean GROUP 1 - mean GROUP 2 \n                    5427.85 \n\n\n\n\nModel Selection Figures\nAnd a figure summarizing all this\n\nmodels_cor <- c(\"Divergence With Gene Flow 1\",\"Divergence With Gene Flow 2\",\"Divergence With Gene Flow 3\",\n            \"Divergence Only 1\", \"Divergence Only 2\",\"Divergence Only 3\",\n            \"Gene Flow Only Full\", \"Gene Flow Only 1\", \"Gene Flow Only 2\", \"Gene Flow Only 3\",\n            \"n-island\", \"panmixia\")\n\nlikesPlot_cor <- likelist_cor %>% bind_rows() %>% group_by(model) %>% \n              ggplot(mapping = aes(x=model, y = bezier.corrected)) +\n              geom_violin(draw_quantiles = 0.5) +\n              theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n              scale_x_discrete(labels = models_cor) +\n              labs(x = \"Metapopulation Model\", y = \"Bezier Corrected Marginal Likelihood\")\nlikesPlot_cor\n\n\n\n\n\n\nFinal Parameter Estimates\nThese are the final estimates, summed over loci.\nHere are the priors I’m using for the equilibrium models, as a reminder.\nbayes-priors= THETA WEXPPRIOR: 0.0 0.001 0.1000000 0.01000 \nbayes-priors= MIG WEXPPRIOR: 0.0100 10000.000000 100000000 10000\n\n\nRead in the posterior and make a labeling key\n\nrepsDir <- \"~/Library/CloudStorage/OneDrive-ThePennsylvaniaStateUniversity/Research/Etelis/migrate_output/coruscans\"\n\n# for some reason the bayesallfile has 39 columns, but only 31 are labelled.\n\n# read in a population key to translate numbers into names in figures\npopkey <- read_csv(\"coruscans/popkey.csv\")\nnames(popkey$Pop) <- popkey$Index\n\n\nwinningModel <- \"full\"\n\nposteriors <- list()\n\n#read in the posterior for one replicate this may take 5 minutes\nfor(r in 1:3){\n  print(paste(\"Loading Rep\",r))\n  posteriors[[r]] <- read.table(file.path(repsDir,paste0(\"rep\",r),winningModel,\n                                      \"bayesallfile\"), header=T) \n}\n\n#combine into one, and then keep only the first 2 reps (based on diagnostics below)\nposterior <- posteriors %>% bind_rows(.id = \"rep\") %>% \n                                filter(rep <= 1) %>% migrants.per.gen()\n\n\n# posterior_long <- posterior %>% \n#                   pivot_longer(starts_with(c(\"Theta_\", \"M_\", \"Nm_\",\"D_\", \"d_\")),\n#                                names_to = \"parameter\", \n#                                values_to = \"value\")\n#make a new labeling key\nposterior_parameters <- names(posterior)[str_which(names(posterior),\n                                                   paste(c(\"Theta_\", \"M_\", \n                                                           \"Nm_\",\"D_\", \"d_\"), \n                                                         collapse = \"|\"))]\n\nparameter_key <- posterior_parameters %>% \n                                  str_replace(\"(\\\\d)_(\\\\d)\", \"\\\\1 to \\\\2\") %>%\n                                  str_replace(\"M_\", \"m/mu \" ) %>% \n                                  str_replace(\"Theta_\", \"theta \") %>% \n                                  str_replace_all(popkey$Pop) %>% \n                                  str_replace(\"Nm_\", \"4Nem \") \n                                  \n\nnames(parameter_key) <- posterior_parameters\n\n\n\nCheck Convergence\n\n#thin by taking every other step\nposteriors2 <- lapply(posteriors,filter,Steps%%500==0)\n# select parameters only\nposteriors2 <- lapply(posteriors2, select, starts_with(c(\"Theta_\", \"M_\", \n                                                          \"Nm_\",\"D_\",\"d_\")))\n\n                        \nposteriors.mcmc <- mcmc.list(lapply(posteriors2,mcmc,thin=500))\nposterior.ggs <- ggs(posteriors.mcmc, burnin = F)\neffectiveSize(posteriors2[[1]])\n#ggmcmc(posterior.ggs, param_page = 4)\n\nTook 51 minutes to generate the ggmcmc output, but everything looks really really good, other than the Geweke diagnostics… need to look that up.\n\n\nEffective Sizes\nEffective sizes are good for one replicate\neffectiveSize(posteriors2[[1]]) (first replicate)\n\nTheta_1    Theta_2    Theta_3    Theta_4      M_2_1      M_3_1      M_4_1      M_1_2      M_3_2 \n  56487.86 1122681.80   75221.67   22195.94  395848.98 2059638.34  996418.98  356999.16  493093.13 \n     M_4_2      M_1_3      M_2_3      M_4_3      M_1_4      M_2_4      M_3_4 \n 428010.34  865528.01  330380.72 1714705.09 1181245.08  537577.93 1897040.34\n\n\n\nGelman-Rubin Diagnostic\nGelman-Rubin diagnostic great, both transformed and untransformed!\n\ngelman.diag(posteriors.mcmc)\n\n# Potential scale reduction factors:\n# \n#         Point est. Upper C.I.\n# Theta_1       1.00       1.00\n# Theta_2       1.00       1.00\n# Theta_3       1.00       1.00\n# Theta_4       1.00       1.00\n# M_2_1         1.00       1.01\n# M_3_1         1.00       1.01\n# M_4_1         1.00       1.00\n# M_1_2         1.00       1.00\n# M_3_2         1.00       1.00\n# M_4_2         1.00       1.00\n# M_1_3         1.00       1.01\n# M_2_3         1.00       1.01\n# M_4_3         1.00       1.00\n# M_1_4         1.01       1.01\n# M_2_4         1.00       1.00\n# M_3_4         1.01       1.01\n# \n# Multivariate psrf\n# \n# 1\n\ngelman.diag(posteriors.mcmc, transform = T)\n\n\nTheta Estimates\nAnd here I run the code for the \\(\\theta\\) estimates\n\nparameter_type <- \"Theta\"\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nthetas <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,0.001,0.1))\n\n#convert to long format\nthetas_long <- thetas %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\ntheta.colors <- brewer.pal(4,\"Spectral\")\ntheta.colors.light <- lighten(theta.colors)\ntheta.colors.dark <- darken(theta.colors)\n\n#plot\nthetas_density <-  ggplot(thetas_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(linewidth = 1) + \n        #scale_x_log10(limits = c(5e-4,1e-2)) + \n        scale_color_discrete(type = theta.colors, \n                             labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\") +\n        ylim(0,0.125) + xlim(0,0.0025)\n\nthetas_ridges <- ggplot(thetas_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$\\\\Theta$\")) + xlim(0,0.0025)\n\nthetas_violins <- ggplot(thetas_long, aes(x = Parameter, y = x, \n                                          violinwidth = Density*10, \n                                          fill = Parameter)) +\n        geom_violin(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_x_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(y = TeX(\"$\\\\Theta$\")) + ylim(0,0.0025)\n\nggsave(\"./coruscans/migrate/theta_density_full.jpg\", plot = thetas_density)\nggsave(\"./coruscans/migrate/theta_ridges_full.jpg\", plot = thetas_ridges)\nggsave(\"./coruscans/migrate/theta_violins_full.jpg\", plot = thetas_violins)\n\n# get stats for each summed-over-loci posterior\n\ntheta_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = thetas, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n#write.csv(theta_stats,\"./coruscans/migrate/theta_stats_full.csv\")\n\nTheta estimates:\n\nthetastats <- read_csv(\"./coruscans/migrate/theta_stats_full.csv\")\n\nNew names:\nRows: 4 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nthetastats\n\n\n\n  \n\n\n\n \n\n\n\nTheta Violins\n\n\n\n\nm/mu estimates\n\nparameter_type <- \"M\"\n\n# use this to figure out the granularity of the prior needed for summarize_prior\n#seq(0,100000, length.out = 2^17)\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nMs <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,10000,100000), n = 2^17)\n\n#convert to long format\nMs_long <- Ms %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\n\nmigration.colors <- c(theta.colors[1],theta.colors.dark[1],theta.colors.light[1],\n                      theta.colors[2],theta.colors.dark[2],theta.colors.light[2],\n                      theta.colors[3],theta.colors.dark[3],theta.colors.light[3],\n                      theta.colors[4],theta.colors.dark[4],theta.colors.light[4])           \n#plot\nMs_density <-  ggplot(Ms_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(size = 1) + \n        scale_x_log10(limits = c(1,3000)) + \n        scale_color_discrete(type = migration.colors, labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\")\n  \n           \n#plot\nM_ridges <- ggplot(Ms_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        #scale_x_log10(limits = c(1,2000)) +\n        scale_fill_discrete(type = migration.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$\\\\frac{m}{\\\\mu}$\")) + xlim(0,1200)\n\n  \nM_violins <- ggplot(Ms_long, aes(x = Parameter, y = x, violinwidth = Density*20, \n                    fill = Parameter)) +\n        geom_violin(stat = \"identity\") +\n        scale_y_log10(limits = c(1,1200)) +\n        scale_fill_discrete(type = migration.colors, labels = parameter_key) \n\n# ggsave(\"./coruscans/migrate/Mmu_density_full.pdf\", plot = Ms_density)\n# ggsave(\"./coruscans/migrate/Mmu_ridges_full.pdf\", plot = M_ridges)\n# ggsave(\"./coruscans/migrate/Mmu_violins_full.pdf\", plot = M_violins)\n\n# get stats for each summed-over-loci posterior\n\nMs_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = Ms, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n\n#write.csv(Ms_stats,\"./coruscans/migrate/Mmu_stats_full.csv\")\n\nM/mu estimates:\n\nms_stats <- read_csv(\"./coruscans/migrate/Mmu_stats_full.csv\")\n\nNew names:\nRows: 12 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nms_stats\n\n\n\n  \n\n\n\n\n\n\nM/mu Density\n\n\n\n\n\nM/mu Ridges\n\n\n\n\n\nM/mu Violins\n\n\n\n\n4Nem estimates\n\nparameter_type <- \"Nm\"\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nnms <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,10,100), n = 2^14)\n\n#convert to long format\nnms_long <- nms %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\n          \n#plot\nNms_density <-  ggplot(nms_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(size = 1) + \n        #scale_x_log10(limits = c(5e-4,1e-2)) + \n        scale_color_discrete(type = migration.colors, labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\") +\n         xlim(0,1.5)\n  \n           \n#plot\nnm_ridges <- ggplot(nms_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        scale_fill_discrete(type = migration.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$4N_em$\")) +\n        xlim(0,1.5)\n  \nnm_violins <- ggplot(nms_long, aes(x = Parameter, y = x, violinwidth = Density*20, \n                    fill = Parameter)) +\n        geom_violin(stat = \"identity\") + \n        scale_fill_discrete(type = migration.colors, labels = parameter_key) +\n        ylim(0,1.5)\n# get stats for each summed-over-loci posterior\n\nnms_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = nms, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n\nggsave(\"./coruscans/migrate/Nm_density_full.pdf\", plot = Nms_density)\nggsave(\"./coruscans/migrate/Nm_ridges_full.pdf\", plot = nm_ridges)\nggsave(\"./coruscans/migrate/Nm_violins_full.pdf\", plot = nm_violins)\nwrite.csv(nms_stats,\"./coruscans/migrate/Nm_stats_full.csv\")\n\n\\(4N_em\\) estimates:\n\nnms_stats <- read_csv(\"./coruscans/migrate/Nm_stats_full.csv\")\n\nNew names:\nRows: 12 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nnms_stats\n\n\n\n  \n\n\n\n\n\n\n4Nm Density\n\n\n\n\n\n4Nm Ridges\n\n\n\n\n\n4Nm Violins\n\n\n\n\n\n\nE. carbunculus\n\nModel Marginal Likelihoods\n\nrunDir_car <- \"carbunculus/migrate/output5\"\n\nlikelist_car <- list()\nfor(r in 1:5){\n  rep = paste0(\"rep\",r)\n  print(rep)\n  likelist_car[[rep]] <- harvest.model.likelihoods(workingDir=file.path(runDir_car,rep),\n                                                   outfileName = \"outfile_rerun3.txt\")\n}\n\n# Model selection for each replicate...\nlikelist_car %>% map(bfcalcs)\n\nThe final model marginal likelihood estimates based on the mean of 5 replicates:\n\nlike.df_car <-  likelist_car %>% bind_rows() %>% group_by(model)\n\nmeans_car <- like.df_car %>% summarize(bezier.corrected = mean(bezier.corrected))\n  \n\nfinal_model_car <- bfcalcs(means_car)\n\nfinal_model_car\n\n\n\n  \n\n\n\n\n\nT-Test\nDifference between panmixia and the second-place full model is very significant.\n\ntop.choice <- final_model_car$model[which(final_model_car$choice ==1)]\nsecond.choice <- final_model_car$model[which(final_model_car$choice ==2)]\n\npermTS(like.df_car$bezier.corrected[which(like.df_car$model == top.choice)],\n       like.df_car$bezier.corrected[which(like.df_car$model == second.choice)],\n       alternative = \"greater\", method = \"exact.ce\")\n\n\n    Exact Permutation Test (complete enumeration)\n\ndata:  GROUP 1 and GROUP 2\np-value = 0.003968\nalternative hypothesis: true mean GROUP 1 - mean GROUP 2 is greater than 0\nsample estimates:\nmean GROUP 1 - mean GROUP 2 \n                   5492.338 \n\n\n\n\nModel-Selection Figures\nAnd a figure summarizing all this\n\nmodels <- c(\"Divergence With Gene Flow 1\",\"Divergence With Gene Flow 2\",\n            \"Divergence Only 1\", \"Divergence Only 2\",\n            \"Gene Flow Only 1\", \"Gene Flow Only 2\", \"Gene Flow Only Full\",\n            \"n-island\", \"panmixia\")\n\nlikesPlot_car <- likelist_car %>% bind_rows() %>% group_by(model) %>% \n              ggplot(mapping = aes(x=model, y = bezier.corrected)) +\n              geom_violin(draw_quantiles = 0.5) +\n              theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n              scale_x_discrete(labels = models) +\n              labs(x = \"Metapopulation Model\", y = \"Bezier Corrected Marginal Likelihood\")\nlikesPlot_car\n\n\n\n\n\n\nFinal Parameter Estimates\nThese are the final estimates, summed over loci.\nHere are the priors I’m using for the equilibrium models, as a reminder.\nbayes-priors= THETA WEXPPRIOR: 0.0 0.001 0.1000000 0.01000 \nbayes-priors= MIG WEXPPRIOR: 0.0100 10000.000000 100000000 10000\n\n\nRead in the posterior and make a labeling key\n\nrepsDir <- \"~/Library/CloudStorage/OneDrive-ThePennsylvaniaStateUniversity/Research/Etelis/migrate_output/carbunculus/output5\"\n\n# for some reason the bayesallfile has 39 columns, but only 31 are labelled.\n\n# read in a population key to translate numbers into names in figures\npopkey <- read_csv(\"carbunculus/popkey.csv\")\nnames(popkey$Pop) <- popkey$Index\n\n\nwinningModel <- \"geneflow_only_full\"\n\nposteriors <- list()\n\n#read in the posterior for one replicate this may take 5 minutes\nfor(r in 2:4){\n  print(paste(\"Loading Rep\",r))\n  posteriors[[r]] <- read_tsv(file.path(repsDir,paste0(\"rep\",r),winningModel,\n                                      \"bayesallfile\"), comment = \"#\") \n}\n\n# This creates an empty element number one, set that to null\nposteriors[[1]] <- NULL\n\n\n#combine into one, and then keep only the first 1 rep (based on diagnostics below)\n#also need to do this to keep \"rep\" as a column for summarizing over loci function.\nposterior <- posteriors %>% bind_rows(.id = \"rep\") %>%  \n                                filter(rep <= 1) %>% migrants.per.gen()\n\n# posterior_long <- posterior %>% \n#                   pivot_longer(starts_with(c(\"Theta_\", \"M_\", \"Nm_\",\"D_\", \"d_\")),\n#                                names_to = \"parameter\", \n#                                values_to = \"value\")\n#make a new labeling key\nposterior_parameters <- names(posterior)[str_which(names(posterior),\n                                                   paste(c(\"Theta_\", \"M_\", \n                                                           \"Nm_\",\"D_\", \"d_\"), \n                                                         collapse = \"|\"))]\n\nparameter_key <- posterior_parameters %>% \n                                  str_replace(\"(\\\\d)_(\\\\d)\", \"\\\\1 to \\\\2\") %>%\n                                  str_replace(\"M_\", \"m/mu \" ) %>% \n                                  str_replace(\"Theta_\", \"theta \") %>% \n                                  str_replace_all(popkey$Pop) %>% \n                                  str_replace(\"Nm_\", \"4Nem \") \n                                  \n\nnames(parameter_key) <- posterior_parameters\n\n\n\nCheck Convergence\n\n#thin by taking every 5 steps\nposteriors2 <- map(posteriors,filter,Steps%%500==0)\n#posteriors2 <- map(posteriors2, select, -mL_harmonic) #remove mL_harmonic, which took in extra unlabeled columns\n# select parameters only\nposteriors2 <- lapply(posteriors2, select, starts_with(c(\"Theta_\", \"M_\", \n                                                          \"Nm_\",\"D_\",\"d_\")))\n\n                        \nposteriors.mcmc <- mcmc.list(lapply(posteriors2,mcmc,thin=500))\nposterior.ggs <- ggs(posteriors.mcmc, burnin = F)\neffectiveSize(posteriors.mcmc[[1]])\n#ggmcmc(posterior.ggs, param_page = 4)\n\nTook 51 minutes to generate the ggmcmc output, but everything looks really really good, other than the Geweke diagnostics… need to look that up.\n\n\nEffective Sizes\nEffective sizes are good for one replicate - although this isn’t broken up by locus.\neffectiveSize(posteriors2[[2]]) #same results achieved for effectiveSize(posteriors.mcmc[[2]])\nTheta_1 Theta_2 Theta_3   M_2_1   M_3_1   M_1_2   M_3_2   M_1_3   M_2_3 \n4725164 4925675 4731644 4285552 4023338 4464066 4439156 4072776 5068390 \n\n\n\nGelman-Rubin Diagnostic\nGelman-Rubin diagnostic perfect, both transformed and untransformed!\n\ngelman.diag(posteriors.mcmc)\n\nPotential scale reduction factors:\n\n        Point est. Upper C.I.\nTheta_1          1          1\nTheta_2          1          1\nTheta_3          1          1\nM_3_2            1          1\nM_1_3            1          1\nD_3_2            1          1\nD_1_3            1          1\n\nMultivariate psrf\n\n1\n\ngelman.diag(posteriors.mcmc, transform = T)\n\n\nTheta Estimates\nAnd here I run the code for the \\(\\theta\\) estimates\n\nparameter_type <- \"Theta\"\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nthetas <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,0.001,0.1))\n\n#convert to long format\nthetas_long <- thetas %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\ntheta.colors <- brewer.pal(3,\"Spectral\")\ntheta.colors.light <- lighten(theta.colors)\ntheta.colors.dark <- darken(theta.colors)\n\n#plot\nthetas_density <-  ggplot(thetas_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(linewidth = 1) + \n        #scale_x_log10(limits = c(5e-4,1e-2)) + \n        scale_color_discrete(type = theta.colors, \n                             labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\") +\n        ylim(0,0.06) + xlim(0,0.0125)\n\nthetas_ridges <- ggplot(thetas_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$\\\\Theta$\")) + xlim(0,0.0125)\n\nthetas_violins <- ggplot(thetas_long, aes(x = Parameter, y = x, \n                                          violinwidth = Density*10, \n                                          fill = Parameter)) +\n        geom_violin(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_x_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(y = TeX(\"$\\\\Theta$\")) + ylim(0,0.0125)\n\n#ggsave(\"./carbunculus/migrate/theta_density_full.jpg\", plot = thetas_density)\n#ggsave(\"./carbunculus/migrate/theta_ridges_full.jpg\", plot = thetas_ridges)\n#ggsave(\"./carbunculus/migrate/theta_violins_full.jpg\", plot = thetas_violins)\n\n# get stats for each summed-over-loci posterior\n\ntheta_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = thetas, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n#write.csv(theta_stats,\"./carbunculus/migrate/theta_stats_full.csv\")\n\nTheta estimates:\n\nthetastats <- read_csv(\"./carbunculus/migrate/theta_stats_full.csv\")\n\nNew names:\nRows: 3 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nthetastats\n\n\n\n  \n\n\n\n \n\n\n\nTheta Violins\n\n\n\n\nm/mu estimates\n\nparameter_type <- \"M\"\n\n# use this to figure out the granularity of the prior needed for summarize_prior\n#seq(0,100000000, length.out = 2^17)\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nMs <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,10000,100000), n = 2^17)\n\n#convert to long format\nMs_long <- Ms %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\n\nmigration.colors <- c(theta.colors[1],theta.colors.dark[1],theta.colors.light[1],\n                      theta.colors[2],theta.colors.dark[2],theta.colors.light[2],\n                      theta.colors[3],theta.colors.dark[3],theta.colors.light[3])\n                                 \n#plot\nMs_density <-  ggplot(Ms_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(linewidth = 1) + \n        scale_x_log10(limits = c(100,1000)) + \n        scale_color_discrete(type = theta.colors, labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\")\n  \n           \n#plot\nM_ridges <- ggplot(Ms_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        #scale_x_log10(limits = c(1,2000)) +\n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$\\\\frac{m}{\\\\mu}$\")) + xlim(0,1000)\n\n  \nM_violins <- ggplot(Ms_long, aes(x = Parameter, y = x, violinwidth = Density*20, \n                    fill = Parameter)) +\n        geom_violin(stat = \"identity\") +\n        scale_y_log10(limits = c(100,1000)) +\n        scale_fill_discrete(type = theta.colors, labels = parameter_key) \n\n# ggsave(\"./carbunculus/migrate/Mmu_density_full.jpg\", plot = Ms_density)\n# ggsave(\"./carbunculus/migrate/Mmu_ridges_full.jpg\", plot = M_ridges)\n# ggsave(\"./carbunculus/migrate/Mmu_violins_full.jpg\", plot = M_violins)\n\n# get stats for each summed-over-loci posterior\n\nMs_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = Ms, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n\n#write.csv(Ms_stats,\"./carbunculus/migrate/Mmu_stats_full.csv\")\n\nM/mu estimates:\n\nms_stats <- read_csv(\"./carbunculus/migrate/Mmu_stats_full.csv\")\n\nNew names:\nRows: 6 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nms_stats\n\n\n\n  \n\n\n\n\n\n\nM/mu Density\n\n\n\n\n\nM/mu Ridges\n\n\n\n\n\nM/mu Violins\n\n\n\n\n4Nem estimates\n\nparameter_type <- \"Nm\"\n\nparameters <- names(posterior) %>%\n                        str_subset(parameter_type)\n\nparameter_key2 <- parameters\nnames(parameter_key2) <- parameter_key[names(parameter_key) %in% parameter_key2]\n\n#summarize the posterior for theta\nnms <- summarize_posterior(posterior, parameter_type = parameter_type, \n                              prior_params = c(0,10,100), n = 2^14)\n\n#convert to long format\nnms_long <- nms %>% select(all_of(c(\"x\",\"prior\",parameters))) %>% \n                pivot_longer(starts_with(c(paste0(parameter_type,\"_\"))), \n                            names_to = \"Parameter\",\n                            values_to = \"Density\")\n\n          \n#plot\nNms_density <-  ggplot(nms_long, aes(x = x, y = Density, \n                    color = Parameter)) +\n        geom_line(size = 1) + \n        #scale_x_log10(limits = c(5e-4,1e-2)) + \n        scale_color_discrete(type = theta.colors, labels = parameter_key) +\n        geom_line(aes(x = x, y=prior), color = \"grey\",\n                  linetype=\"dotted\") +\n         xlim(0,2.5)\n  \n           \n#plot\nnm_ridges <- ggplot(nms_long, aes(x = x, y = Parameter, height = Density, \n                    fill = Parameter)) +\n        geom_density_ridges(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        scale_y_discrete(limits = rev, labels = NULL, breaks = NULL) +\n        labs(x = TeX(\"$4N_em$\")) +\n        xlim(0,2.5)\n  \nnm_violins <- ggplot(nms_long, aes(x = Parameter, y = x, violinwidth = Density*20, \n                    fill = Parameter)) +\n        geom_violin(stat = \"identity\") + \n        scale_fill_discrete(type = theta.colors, labels = parameter_key) +\n        ylim(0,2.5)\n# get stats for each summed-over-loci posterior\n\nnms_stats <- parameter_key2 %>% map_dfr(.f = ~ posterior_stats(df = nms, \n                                                             parameter = .x),\n                                      .id = \"parameter\")\n\nggsave(\"./carbunculus/migrate/Nm_density_full.jpg\", plot = Nms_density)\nggsave(\"./carbunculus/migrate/Nm_ridges_full.jpg\", plot = nm_ridges)\nggsave(\"./carbunculus/migrate/Nm_violins_full.jpg\", plot = nm_violins)\nwrite.csv(nms_stats,\"./carbunculus/migrate/Nm_stats_full.csv\")\n\n\\(4N_em\\) estimates:\n\nnms_stats <- read_csv(\"./carbunculus/migrate/Nm_stats_full.csv\")\n\nNew names:\nRows: 6 Columns: 10\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(1): parameter dbl (9): ...1, 2.5%, 25%, 50%, 75%, 97.5%, mode, mean, sd\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n\nnms_stats\n\n\n\n  \n\n\n\n\n\n\n4Nm Density\n\n\n\n\n\n4Nm Ridges\n\n\n\n\n\n4Nm Violins"
  },
  {
    "objectID": "Etelis_migrate.html#read-bayesfile",
    "href": "Etelis_migrate.html#read-bayesfile",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Read Bayesfile",
    "text": "Read Bayesfile\nThese functions are for reconstructing distributions from the bayesfile which consists of distributions for each locus calculated as histograms\n\nbayesfilenames <- c(\"Locus\",\"pnumber\",\"HPC50\",\"HPC95\",\"value\",\"count\",\n                    \"freq\",\"cumFreq\",\"priorFreq\")\n\nbf <- read_table(file = file.path(winningModelDir,\"bayesfile\"), \n                             col_types = \"ifiiddddd\", col_names = bayesfilenames,\n                             comment = \"#\", skip_empty_rows = T)\n\nparameter_number_table <- read_table(file = file.path(winningModelDir,\"bayesfile\"), \n                             col_types = \"cic\", \n                             col_names = c(\"drop\",\"pnumber\",\"parameter\"),\n                             skip=9, n_max = 16) %>% \n                      select(-drop) %>%\n                      mutate(parameter = str_replace_all(parameter, \",\",\"_\")) %>% \n                      mutate(parameter = str_remove_all(parameter,\"\\\\(\")) %>% \n                      mutate(parameter = str_remove_all(parameter,\"\\\\)\")) %>% \n                      left_join(tibble(parameter_name =\n                                        parameter_key,\n                                       parameter=names(parameter_key)),\n                                by = \"parameter\")\n\nparameter_number_key <- parameter_number_table$parameter_name \nnames(parameter_number_key) <- parameter_number_table$pnumber\n\n#bf %>% ggplot(aes(x=value, y = freq, color = Locus)) + \n#  geom_line() + scale_color_continuous() + \n#  facet_wrap(vars(Parameter), scales = \"free\")\n\n# bf %>% filter(pnumber %in% 1:9) %>% filter(Locus %in% 1:109) %>% \n#       ggplot(aes(x=value, y = freq, color = Locus)) + geom_line() +\n#       facet_wrap(vars(pnumber), scales = \"free\")"
  },
  {
    "objectID": "Etelis_migrate.html#theta",
    "href": "Etelis_migrate.html#theta",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "Theta",
    "text": "Theta\n\nbf %>% filter(pnumber %in% 1:4) %>% filter(Locus == 440) %>% \n      ggplot(aes(x = value, y = freq, color = pnumber)) + geom_line() +\n      scale_color_brewer(palette = \"YlGnBu\", labels = parameter_number_key) +\n      ylim(0,0.02) + xlim(0,0.015) + geom_line(aes(x = value, y = priorFreq),\n                                             color = \"grey\", linetype=\"dotted\")"
  },
  {
    "objectID": "Etelis_migrate.html#mmu",
    "href": "Etelis_migrate.html#mmu",
    "title": "Gene Flow Models for Etelis spp. Deepwater Snappers",
    "section": "M/mu",
    "text": "M/mu\n\nbf %>% filter(pnumber %in% 6:16) %>% filter(Locus == 440) %>% \n      ggplot(aes(x = value, y = freq, color = pnumber)) + geom_line() +\n      #scale_color_brewer(palette = \"YlGnBu\", labels = parameter_number_key) +\n      geom_line(aes(x = value, y = priorFreq),\n                                             color = \"grey\", linetype=\"dotted\") +\n      scale_x_log10(limits = c(1e4,1e6)) + ylim(0,0.05)"
  }
]